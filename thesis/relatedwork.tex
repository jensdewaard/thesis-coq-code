\chapter{Related Work}
In this section we'll discuss recent advances made by others in the field of 
abstract interpretation. We'll discuss different ways of defining interpreters,
defining Galois connections in a constructive way and decomposing interpreters.

\section{Definitional interpreters}
Proof assistants can be used to mechanize the proof of abstract interpreters.
However, as this can be tedious work, much effort has been put into easing the
proof burden. Darais et al~\cite{darais2017abstracting} have focused on
abstracting definitional interpreters in order to increase the modularity of
the abstract interpreters. 

Definitional interpreters leave certain aspects of the computations implicit 
by defining the language that is to be analyzed in a different 
language~\cite{reynolds1972definitional}, like how we define our Toy language 
in Coq. 

One of the problems Darais described was non-termination of the abstract
definitional interpreter. This was solved by using a cache that mapped program
configuration pairs of values and stores. This prevented the interpreter from
entering an infinite loop.

\section{Constructive Galois connections}
Sergey et al.\cite{sergey2013monadic} have described a method to create a
monadic abstract interpreter
from concrete semantics in Haskell. Like in this thesis, they extract elements
such as access to a store in a monadic typeclass that is then instantiated in a
concrete and abstract manner. Because their work is in Haskell as opposed to
Coq, they do not have to deal with the limitations of the calculus of inductive
constructions. Mostly, they are able to define both alpha and gamma in their
work. 

When we defined our Galois connections, we were only able to define the gamma
functions. Normally, Galois connections are made from two functions, the
other being alpha. The alpha function would be responsible for transforming
the concrete values into the abstract values that best encompass those concrete
values. However, defining the alpha function in Coq requires the use of
non-constructive axioms~\cite{Monniaux3}.

Darais et al~\cite{darais2019constructive}, describe a method to define
constructive Galois connections.
connections. Instead of defining the functions \coq{γ : A → C } 
and \coq{α : C → A }, they define an extraction function 
\coq{η : ℕ → ℙ } and
an interpretation function \coq{μ : ℙ →  ℘ ℕ }. 
When defining Galois connections in terms of \coq{η } and \coq{μ }, they
are able to derive an abstract interpreter via the calculational approach, a
method to calculate the abstract interpreter from the concrete interpreter.
Our work, in contrast, requires explicitly constructed concrete and abstract
interpreters.

The extraction function \coq{η }is comparable to the extract functions in the
IsNat and IsBool typeclasses that we've implemented. If we moved those to the
Galois typeclass, we would have obtained something similar to the constructive
Galois connections. Because we work with explicit concrete and abstract
interpreters derived from a shared intepreter, we've kept our definition of a
Galois connection closer to the classical definition, albeit without an alpha
function.

%In \cite{darais2015galois}, Darais uses NonDetT to capture the possibility of
%failure instead of MaybeT. This also imposes a requirement of a
%join-semilattice on the inner monad, like we encountered in
%Section~\ref{sec:maybeAT_join}. Darais achieves this by redefining the domain
%of the store to a powerset.

\section{Shared interpreters}
As mentioned in the introduction, the idea for sharing a generic interpreter
between the concrete and abstract interpreters comes from the work of Keidel et
ala~\cite{keidel2020compositional}. In this paper, Keidel proposes a
methodology for defining abstract and concrete interpreters in a way that
allows the soundness proof to be decomposed along the lines of the shared
interpreter.

%Keidel et al.~\cite{keidel2018compositional} instead propose a way to split up
%the concrete and abstract interpreters by defining a shared structure. By
%implementing the concrete and abstract interpreters as instances of a shared
%intrepreter, the soundness proof of the abstract interpreter can be decomposed
%into smaller lemmas, each focusing on how the two instances differ from the
%shared part. It is this paper that serves as the basis for this thesis. However,
%the proofs in Keidels work are pen-and-paper proofs. By implenting the ideas
%presented in Coq instead of Haskell, we can mechanize these pen-and-paper
%proofs, making abstract interpreters that are proven sound more accessible.

One large difference between their work and ours
lies in that we use Monads instead of Arrows to represent 
effects such as stores and exceptions. As
arrows are generalizations of monads~\cite{hughes2000generalising}, we could
rewrite our implementation to use arrows instead, but we have not seen the need
to do so (yet). 

This difference means that we have to decompose our proof along the methods
exposed by the monad typeclass instead of the operations on arrows. Fortunately
we have analogues to the methods used by Keidel. The first is the arrow
composition method \coq{>>> }, which is like the bindM method of monads.  Second,
Keidel uses the parallel composition method \coq{*** }, which takes two arrows 
\coq{g } and \coq{h } and
returns a composed arrow \coq{g *** h }. The composed arrow takes a tuple 
\coq{(x,y) }
and returns \coq{(g x, h y) }. There is no analogue to this method in the standard
monad typeclass, but we can simulate the effects with repeated applications of
the bindM method.

Keidel's choice for arrows was influence by the fact that arrows and their
operations are an algebra. This in turn means that, after defining the
interpreters and the required lemmas, the soundness proof for the concrete and
abstract interpreter is automatically derived. In contrast, use of monads would
mean that the soundness of the interpreters would require another, manual
proof. Fortunately our use of Coq and its automation capabilities means that
providing this proof is trivial.

One of the problems we ran into, as described in Chapter~\ref{sec:challenges},
was the definition of the bind method on our optionAT monad. It required a join
on the value wrapped inside the monad, but an instance of monad cannot impose
contraints on the wrapped value. Keidel works around this by forgoing the use
of arrow transformers in this paper and defining the entire type of the
interpreter from the start. This allows for inlining the joining of the state
and preserving soundness.

In their follow-up paper~\cite{keidel2019sound} Keidel et al. describe a set of
reusable components based on arrow transformers that preserve soundness.
\todoin{insert sven's reply on how he solved join on inner arrow}

\section{Mechanization of Abstract Analysis}
% verasco
A large previous work on the mechanization of abstract analysis in Coq was
Verasco, a verified static analyzer for the C programming
language~\cite{jourdan2016verasco}. Like in
this thesis Verasco only implements the \coq{γ } function of Galois
connections. We were inspired by Verasco's lifting of types to domains that
included top and/or bottom. This allows for defining the relation between the
top value of an abstract domain and concrete values once and for all. 

The intepreter used in Verasco does not use monad transformers; because Verasco
deals with a specific language, there is no need for the flexibility provided
by being able to change the monad stack.

% compcert
%Other related work was done on the CompCert project, which is a formally
%verified C compiler~\cite{leroy2016compcert}. The project aims to
%prevent miscompilation of C programs by proving the correctness of the compiler
%in Coq.
