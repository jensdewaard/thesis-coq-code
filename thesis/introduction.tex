\chapter{Introduction}
Software engineering is an complex discipline. While developing, it
is easy to lose oversight of what the code actually does. 
Many tools have been developed to mitigate this problem and help developers
develop faith in their code.
Unit testing libraries aid in running the program on select inputs to see 
if the result is correct. Fuzzing tools run the
program on random input to see if this elicits a crash. 
Static code analyzers look at the source code of a program to see if
the code will perform as expected. These analyzers do not run the programs under
test, hence the name static. In this thesis, we will consider these static
analyzers.

There exist many kinds of static code analysis. The field is broad, as it
refers to any kind of tool that inspects source code, but we will attempt to
paint a picture to clarify. One type of static code analysis is taint analysis,
which seeks to find security bugs in a program. User input is often a source of
security breaches, as a malicious user could input a specially crafted input. A
taint analyzer considers all user input as tainted, and tracks the flow of
tainted data through the program. Tainted data must be sanitized before it
can be used in a high security context. An example of such sanitization is
clearing a submitted username and password from illegal characters to prevent
an SQL injection attack. Another example of a kind of static analysis is a 
type checker. Type checkers are used in the compilers of many languages and 
assure that the provided program is well-typed. 

As programs that are well-typed should not crash, it is important
that the type checker will not report false positives. To put it in other 
words, it is important that the static analysis is sound. False positives would
mean that the analyzer says the program is okay, but will in fact crash during
runtime. Contrast this with false negatives, in which the analyzer says there
will be a problem that will not actually occur. The measure of such false
negatives is called precision. While a static analyzer need not be totally
precise, it is still desirable to keep the precision as high as possible to
encourage the use of the analyzer.

Proving that static analyzers are sound is a daunting task. Doing it by hand is
a long and cumbersome process, and error prone as a result of this.
Research into abstract interpretation started in the 1970s, in part by Cousot 
and Cousot~\cite{cousot1977abstract} in their 1977 paper. They showed how 
reasoning over
the abstract properties of values could be used to perform program analysis,
despite the resulting abstractions being imprecise. A few years later, they
build upon theirs and other work to define a generic framework to capture the
program flow using abstract interpretation~\cite{cousot1979systematic}.
Cousot then provided a method for designing an abstract interpreter
based on a provided concrete interpreter~\cite{cousot1999calculational}.
Using the Galois connections between
the concrete and abstract values, they showed that it is possible to calculate 
a sound abstract interpreter in what they called the calculational approach.
% TODO does not flow


So how can we further improve upon this situation? Keidel et al. developed a 
framework for decomposing these soundness proofs into smaller,
independent pieces~\cite{keidel2018compositional}.
The idea is that by reusing lemmas and reasoning about 
shared parts between the abstract and concrete interpreters, the resulting 
proof can be shrunk significantly. The abstract and concrete interpreters are 
instantiantions of a shared 
interpreter; this shared interpreter only uses methods exposes by an interface,
and the abstract and concrete interpreters provide abstract and concrete
implementations respectivally of this interface. The problem of proving the
soundness of the abstract interpreter then simplifies to proving the soundness
of the corresponding methods of the interfaces. This paper serves as the basis
for this thesis. 

The proofs in Keidels work are pen-and-paper proofs. By implenting the ideas
presented in Coq instead of Haskell, we can mechanize these pen-and-paper
proofs, making abstract interpreters that are proven sound more accessible.

Prior work with regards mechanically proving the soundness of abstract
interpreters has been done before by Monniaux et al~\cite{Monniaux3}. One of the
results of his work shows that the abstraction function of Galois connections
cannot be formally written in constructive logic. The work of 
Pichardie~\cite{pichardie2005interpretation} builds on this and shows that we
can circumvent this problem by stating the soundness lemmas using the
concretization function only. Darais et al~\cite{darais2016constructive} claim
to have solved this problem with Galois connections that are both general and
constructive.

% Research in proof assistants, what did it add

\section{Problem Statement}
The goal of this thesis is to implement a framework in Coq based on the work by 
Keidel et al. that can be used to ease the development of soundness
proofs of static analyzers, and perform a case study in which the soundness of 
an abstract interpreter is proven using that framework. 
The idea is that in the process of
developing the framework we will be able to articulate best practices for
writing soundness proofs.

\section{Research Questions}

\begin{center}
	\begin{enumerate}
		\item
How can we develop a methodology in Coq to ease the development of
formal proofs for static analyzers?

		\item
	How can we quantify the ease with which soundness proofs are developed?

		\item
	What measures can we apply to the given interpreters to make them easier to
	write proofs for?
	\end{enumerate}
\end{center}
