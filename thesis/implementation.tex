\chapter{Building The Interpreter}
In this chapter we will describe how the framework is implemented in Coq and
the theory behind the implementation. First, in Section \ref{sec:monads} 
we will delve into the theory
behind monads~\cite{wadler1995monads}. We borrow these constructs from the 
Haskell Prelude and reimplement them in Coq. We also leverage the ability of
Coq to directly add laws to our definitions. This makes it impossible for us to
define invalid monads. Secondly, in Section \ref{sec:concrete} we shall describe the 
syntax of a toy language and define a concrete interpreter of this language. We
will show how we can decompose the concrete interpreter due to its monadic
structure. After that, we dive into the theory behind Galois connections. 
After defining Galois connections, we show how there is a Galois connection
between the previously defined concrete interpreter and an example of an
abstract interpreter.
In Section~\ref{sec:soundness}, we show what it means for such an abstract
interpreter to be sound. 

\section{Monads}~\label{sec:monads}
Many tutorials explaining monads exist and monads are generally regarded as
difficult to understand~\cite{petricek2018we}. We will briefly try to explain
them here, though a complete understanding monads is not neccessary to follow 
later sections. Understanding that we can decompose the program along the 
lines of the methods provided by the Monad typeclass is sufficient.

Monads are a way to add impure effects to a pure language. Examples of impure
effects are modifying a global state, throwing and handlings exceptions and
perform IO operations. A Computer Science course~\cite{upenn_monads} at the University of
Pennsylvania likens monads to a recipe, a description of steps to take. Such
descriptions are values themselves, which makes using monads pure.

In Coq we can implement monads in the form of a typeclass~\cite{sozeau2008first}, 
as it is done in Haskell~\cite{wadler1995monads}. Typeclasses are somewhat like interfaces in 
object-oriented programming languages. A programmer can write functions 
operating on typeclasses instead of concrete types, and those functions can
accept all types that implement the functions defined in that specific typeclass. 
In this case, all types belonging to the Monad typeclass must implement two functions,
\textit{bind}, originally called \textit{*} in the paper by Wadler, and 
\textit{return}, originally called \textit{unit}. An implementation of monads
as a typeclass in Coq is given in Listing \ref{lst:sample_monad}.

\begin{minted}{coq}
Class Monad (M : Type → Type) : Type :=
{
  returnM : ∀ {A}, A → M A;
  bindM : ∀ {A B}, M A → (A → M B) → M B;
}.
Notation "m >>= f" := (bindM m f) (at level 40, left associativity).
\end{minted}

Because return is a reserved keyword in Coq, we rename both \coq{return } and 
\coq{bind } into \coq{returnM } and \coq{bindM } respectively.
\coq{returnM } takes a value and \"wraps\" it in the monad. \coq{bindM } is
a function that can apply a function to a monadic value. As is the convention
in Haskell, we will use \coq{>>= } as an infix notation for the bindM
function.

One of the advantages that Coq typeclasses have over those in Haskell is the
abilty to add lemmas to the typeclass in addition to the methods. Proper monads
have to observe three laws, together called the Monad laws. These laws are, as
written in the original paper
\begin{align*}
    \textit{unit}\ a >>= \lambda b. n =&\ n[a/b] \\
    m >>= \lambda a . \textit{unit}\ a =&\ m \\
    m >>= (\lambda a.n >>= \lambda b.o) =&\ (m >>= \lambda a.n) >>= \lambda b.o
\end{align*}

In English, these mean that binding \coq{returnM } to a function f is
equivalent to just applying \coq{f } to the value wrapped by \coq{returnM }. The
second law states that binding to \coq{returnM } is effectively a no-op, and
the last law requires \coq{bindM } to be associative. In Coq, we can add the
following lemmas to the Monad typeclass to ensure that all typeclass instances
are valid monads, which is something that Haskell cannot guarantee. 

\begin{listing}[H]
\begin{minted}{coq}
Class Monad (M : Type → Type) : Type := {
  bind_id_left : ∀ {A B} (f : A → M B) (a : A), 
    bindM (returnM a) f = f a;
  bind_id_right : ∀ {A} (m : M A),
    bindM m returnM = m;
  bind_assoc : ∀ {A B C} (m : M A) (f : A → M B) (g : B → M C),
    bindM (bindM m f) g = bindM m (λ a, bindM (f a) g);
}
\end{minted}
\caption{Lemmas for the monad laws}
\label{lst:monad_lemmas}
\end{listing}

In this thesis, we consider monads that add two different side effects. The
first is the option monad, also known as Maybe in the Haskell standard library. 
The option monad adds the
possibility of failure to an operation. The other is the State monad, which
allows us to keep track of a global state. In the next few sections we will
discuss the implementation of these monads.

\subsection{Option}
\begin{minted}{coq}
Inductive option A : Type :=
    | Some : A → option A
    | None : option A.
\end{minted}

The first monad we implemented was the option monad. Values of the type
\mintinline{coq}{option A } can be of either the form 
\mintinline{coq}{Some a }, where \coq{a } is a value of type \coq{A }, or 
\mintinline{coq}{None }. Here, \coq{None } represent a failed
computation. For example, a monadic version of division \coq{nat →
nat → option nat } could return \coq{None } when dividing by zero,
and a \coq{Some } value with the right answer in other cases.

The return method of \coq{option } is the same as the \coq{option } constructor. 
The \coq{bindM } method of the \coq{option } monad performs a case analysis on the provided
value. In the case of \coq{Some }, it extracts the inner value and applies the given
function to it. In the case of \coq{None }, it returns \coq{None }. This allows the chaining
of multiple operations without explicit error handling between each step.

\begin{minted}{coq}
  Definition bind_option {A B} 
  (m : option A) (k : A → option B) : option B :=
    match m with
    | None => None
    | Some a => k a
    end
\end{minted}

Because we can use \coq{Some } as the \coq{returnM } method of \coq{option }, we
can now move on to proving the monadic laws. These laws require that
\coq{returnM } is a left and right identity for \coq{bindM }, and that 
\coq{bindM } is associative. If we've proven this, we can combine those three lemma's
together with the definition of \coq{bind_option } and \coq{Some } into an
instance for the \coq{Monad } typeclass. The Coq code for this can be seen in
Listing \ref{lst:monad_option}. Note that the proofs have been omitted for
brevity.

\begin{listing}
\begin{minted}{coq}
  Lemma bind_option_id_left : ∀ {A B} (f : A → option B) (a : A), 
    bind_option (Just a) f = f a.

  Lemma bind_option_id_right : ∀ {A} (m : option A), 
    bind_option m Just = m.

  Lemma bind_option_assoc : ∀ {A B C} (m : option A) 
    (f : A → option B) (g : B → option C),
  bind_option (bind_option m f) g = bind_option m (λ a : A, bind_option (f a) g).

  Global Instance monad_option : Monad option :=
  {
    returnM := Some;
    bindM := bind_option;
    bind_id_left := bind_option_id_left;
    bind_id_right := bind_option_id_right;
    bind_assoc := bind_option_assoc;
  }. 
\end{minted}
\caption{Instance of the Monad typeclass for option}
\label{lst:monad_option}
\end{listing}

\subsection{State}
When we evaluate a program, we will require a way to keep track of a global
state. This state can be as simple as an integer that keeps a count of the
number of operations performed. In our case, we will use a map of strings to
values \coq{V },  modelling the use of variables in our program. The specific type 
of V will be described in a later section.

The State monad allows us to add the ability for tracking state to a pure
program. It is defined as \coq{Definition State (S A : Type) := S → (A * S). } 
The State monad wraps a value in a function that keeps track of an additional value of
type S. Looking at the types of State and return shows us how we ought to
implement the return function for State. 

\begin{minted}{coq}
Definition return_state {S A} : A → State A := 
    λ a : A, λ st : S, (a, st).
\end{minted}

The \coq{bindM } method for State passes the state variable along to the next
computation. Updates states are passed along and the current state is
accessible at each step of the computation operation.

\begin{listing}[H]
\begin{minted}{coq}
  Definition bind_state {A B} 
    (m : State S A) (f : A → State S B) : State S B :=
    λ st, match (m st) with
          | (x, st') => f x st'
          end.
\end{minted}
\caption{The implementation of bind for the State monad}
\label{lst:bind_state}
\end{listing}

Listing~\ref{lst:bind_state} shows us how the bind method is implemented. The
result of binding a State value to a function is a new function (as all values
of State need to be) in which the provided state variable is applied to the
State value. The result of this computation, including the new updated state,
is then passed to the continuation function \coq{f }.

The State and Maybe monads show us how we would implement the desired
properties of our Toy language in a pure manner. But right now, we will have to
change between the two. We can either have the evaluator utilize the State
monad to keep track of state, or have it use the Maybe monad to allow
exceptions, but we cannot have a runtime in which we can both throw exceptions
as well as keep track of a global state. 

There is a way to combine the functionalities of monads via the use of monad
transformers. 

\subsection{Monad Transformers}~\label{sec:monad_transformers}
Monad transformers\cite{liang1995monad} are a way to add the side effects of a
monad to another monad. For both of the monad we've defined earlier, we define
a corresponding type that takes a monad as an input and returns a new monad
instance.

We define two transformer monads that correspond to the monads defined above:
optionT and StateT. These extend a monad by allowing for failing computations
and the ability to retain a global state. 

\begin{listing}
\begin{minted}{coq}
Definition optionT M A: Type := M (option A).
Definition StateT S M A : Type := S → M (A*S)%type.
\end{minted}
\caption{Definitions for the monad transformers}
\end{listing}

When providing instances for the Monad typeclass for these types, we require
the use of the \coq{bindM } and \coq{returnM } methods of the wrapping monad
\coq{M }.
For example, in listing~\ref{lst:bind_optionT}, we see that the implementation 
of \coq{bindM } for \coq{optionT }
unwraps the monad M, exposing the underlying option value. We perform a case
analyis on this value in a way that is similar to how we defined
\coq{bind_option },
\coq{None } values are propagated and values wrapped with \coq{Some } are 
threaded through chained bind calls.

\begin{listing}
\begin{minted}{coq}
  Definition bind_optionT {A B} (x : optionT M A) 
    (f : A → optionT M B) : optionT M B :=
    bindM (M:=M) x (λ v : option A,
      match v with
      | None => returnM None
      | Some a => f a
      end
    ).
\end{minted}
\caption{Implementation of \coq{>>= } for optionT}
\label{lst:bind_optionT}
\end{listing}

Aside from State and option, we also implemented the Identity monad. This monad,
like the identity function, adds no extra functionality. 
\begin{minted}{coq}
Inductive Identity (A : Type) : Type := 
    identity : A → Identity A.
\end{minted}

Its value lies in the
ability to use it where we would a monad in cases where we don't want to add
extra functionality. To reduce our code base, we implemented State as the
StateT transformer applied to the Identity monad. The resulting monad
simplifies to our prior definition of State, without us needing to prove
soundness of the new monad.

\subsection{MonadFail, MonadExcept and MonadState}
With the use of monad transformers and lifting we are able to build a so-called 
monad stack to encode any side effects we may want in a pure way. However, when
we write code that reasons about possible side effects, we do not wish the
remember to exact number of lifts required to get to the underlying monad that
encodes those side effects. 

For this usecase, we have ported MonadFail, MonadExcept and MonadState from
Haskell~\cite{gibbons2011just}. The easiest way to explain why we use these typeclasses is that 
the typeclasses Maybe and State were more concerned with
\textit{how} the side effects were implemented, whereas these typeclasses deal 
more with \textit{what} side effects a type can cause.

\begin{listing}
\begin{minted}{coq}
Class MonadFail M {MM : Monad M} : Type := {
  fail : ∀ {A}, M A;
  fail_left: ∀ {A B} (m : A → M B), (@fail A) >>= m = fail;
}.
\end{minted}
\caption{Definition of the MonadFail typeclass}
\label{lst:monadfail}
\end{listing}

Listing~\ref{lst:monadfail} shows the definition for the \coq{MonadFail } typeclass.
The definition tells us two things: all instances of \coq{MonadFail } have a value
called \coq{fail }, and when this value is used on the left-hand side of a bind, the
resulting value is also \coq{fail }.

The implementation of this typeclass for the option monad is simple. We can use
\coq{None } as the \coq{fail } value. 
The proof for the \coq{fail_left } lemma follows readily from
the definition of \coq{bind_option }. The same goes for optionT, in which case 
our fail value is \coq{returnM None }.

However, things get slightly more interesting when looking at \coq{State } and
\coq{StateT }.
The regual \coq{State } monad is not an instance of \coq{MonadFail }. 
This should not come as
a surprise, as the point of this monad was to add a read/write state and not
the possibility of failure. \coq{StateT }, however, preserves the ability for failure
if the underlying monad is an instance of MonadFail.

\begin{listing}
\begin{minted}{coq}
Section fail_stateT.
  Context {S : Type}.
  Context {M : Type → Type} {MF : MonadFail M}.

  Definition fail_stateT {A} : StateT S M A := fun s : S, 
    fail >>= fun a, return_stateT a.

  Lemma fail_stateT_left : ∀ (A B : Type) (s : A → StateT S M B),
    fail_stateT (A:=A) >>= s = fail_stateT.

  Global Instance monad_fail_stateT : MonadFail (StateT S M) :=
  {
    fail := @fail_stateT;
    fail_left := fail_stateT_left;
  }.
End fail_stateT.
\end{minted}
\caption{The MonadFail instance of StateT}
\label{lst:monadfail_stateT}
\end{listing}

Listing~\ref{lst:monadfail_stateT} shows how the usage of fail method 
of the underlying MonadFail is changed to work for the transformed StateT
monad instead. The proof unfolds the methods defined in terms of StateT and
rewrites the goal based on the monadic laws for bind and the fail\_left lemma.

Now that we have described monads that can fail, it comes natural to think
about monads that can recover from failure. To describe this ability, we have
the MonadExcept typeclass.

\begin{listing}
\begin{minted}{coq}
Class MonadExcept M {MM : Monad M} := {
  throw : ∀ {A}, M A;
  throw_left: ∀ {A B} (f : A → M B), throw >>= f = throw;
  catch : ∀ {A} {JA : Joinable A A} {JAI: JoinableIdem JA}, 
    M A -> M A -> M A;
  catch_left : ∀ {A} {JA : Joinable A A} {JAI : JoinableIdem JA} 
    (x : M A), catch throw x = x;
  catch_right : ∀ {A} {JA : Joinable A A} {JAI : JoinableIdem JA} 
    (x : M A), catch x throw = x;
  catch_return : ∀ {A} {JA : Joinable A A} {JAI : JoinableIdem JA} 
    (x : M A) (a : A), catch (returnM a) x = returnM a;
}.
\end{minted}
\caption{The MonadExcept typeclass}
\label{lst:monadexcept}
\end{listing}

For all instances of MonadExcept, we define a throw value and a catch method. 
These are a lot like try-catch functionality in languages such as Java. 
The throw function is a value of the monad M. The catch function
should take two values of type M A. If the first is throw, it returns the
second provided value. If it is not, it returns the first provided value. This
behaviour is encoded in the lemmas attached to the typeclass.

\begin{listing}
\begin{minted}{coq}
Class MonadState (S : Type) (M : Type -> Type) {MM : Monad M} :=
{
  get : M S;
  put : S -> M unit;
}.
\end{minted}
\caption{The MonadState typeclass}
\label{lst:monadstate}
\end{listing}

In the same way that we use typeclasses to easily access the fail effects, we 
can use a typeclass to access the state that is carried by the (transformed)
monad. Any monad implementing the MonadState typeclass should provide access to
a get method that sets the current state as the 'return value' of the function,
and a put method that updates the carried state with the given value.

\begin{listing}
\begin{minted}{coq}
Section store_stateT.
  Context {S : Type}.
  Context (M : Type → Type) {MM : Monad M}.

  Definition stateT_get := λ s : S, returnM (s, s).

  Definition stateT_put := λ s : S, λ _ : S, returnM (tt, s).

  Global Instance store_stateT : 
  MonadState S (StateT _ M) :=
  {
    get := stateT_get;
    put := stateT_put;
  }.
End store_stateT.
\end{minted}
\caption{The State instance of MonadState}
\label{lst:monadstate_state}
\end{listing}

Now that we've described the monads used in the project and the 
theories behind them, we turn to the implementation of the concrete
interpreter. In the next section, we start by defining the language that is to
be interpreted, and how we compose the monads to do so.

\section{The Concrete Interpreter}\label{sec:concrete}

\subsection{The language : values and statements}
\label{sec:lang}
Programs consist of statements and expressions. These programs are evaluated by
interpreters. In this subsection, we shall describe the syntax of a toy
language.

\begin{minted}{Coq}
Definition cvalue : Type := (nat + bool)%type.
\end{minted}

Our toy language has two types of values. Natural numbers, represented by
the Coq type \coq{nat } and boolean values, represented by \coq{bool }. We
define concrete values as the sum of these two types. A sum of two types is a
type itself and means that values of that type can be of the type of either
its components.

To be able to use this sum type, we create a typeclass to defines how to
convert the component types into the composite type and vice versa. This
implementation was inspired by~\cite{liang1995monad}.

\begin{minted}{coq}
Class SubType (sub : Type) (super : Type) : Type := {
  inject : sub → super;
  project : super → option sub
}.
\end{minted}

The SubType typeclass specifies a relation between two types that can be
converted into one another. The inject method takes a subtype and turns it into
the super type. The project type performs the inverse operation. However,
because a value of the super type is not necessarily an instance of the
subtype, we include the possibility of failure. As an example, we show the
instance of the SubType class that converts between \coq{nat } and \coq{(nat +
bool) }.

\begin{minted}{coq}
Instance subtype_l : ∀ {A B}, SubType A (A + B) := {
  inject := inl;
  project := λ s, match s with | inl x => Some x | _ => None end
}.
\end{minted}

In the above instance, \coq{inl } is the constructor that takes a value \coq{a
: A } and returns a value of type \coq{(A+B) }. Coq will automatically use the
\coq{inject } function to turn a natural number into the composite type \coq{cvalue } using
its typeclass inference mechanism. The \coq{project } function can turn values
of \coq{(A+B) } into values of \coq{option A }. 

Expressions are operations on values that result in a new value. They are
implemented as an inductive type called \coq{expr }. 

\begin{listing}
\begin{minted}{coq}
Inductive expr : Type :=
  | EVal : cvalue → expr
  | EVar : string → expr
  | EPlus : expr → expr → expr
  | EMult : expr → expr → expr
  | EEq : expr → expr → expr
  | ELe : expr → expr → expr
  | ENot : expr → expr
  | EAnd : expr → expr → expr.
\end{minted}
\end{listing}

Expressions can exist of concrete values (`5', `true'), names of variables
saved in a store (see Section~\ref{sec:stores}) and operations on these values
(+, *, ==, \coq{<= }, negation and \coq{&& }). 

\begin{listing}
\begin{minted}{coq}
Inductive com : Type :=
  | CSkip : com
  | CSeq : com → com → com
  | CAss : string → expr → com
  | CIf  : expr → com → com → com
  | CTryCatch : com → com → com
  | CThrow : com. 
\end{minted}
\end{listing}

Statements control the flow of the program. In this case, we have implemented a
skip statement that effectively does nothing, an assigment statement that
assigns the result of an expression to a variable, an if statement, a try-catch
statement and a throw statement that acts as an exception.

\subsubsection{Stores}\label{sec:stores}
When evaluating the assignment statement \coq{CAss } and the variable
expression \coq{EVar }, the interpreter should write to and read from a variable
storage. We call these stores. 

The concrete store is a map\footnote{The \textit{total\_map} comes from 
	Map.v from the public Software Foundations course.\cite{softwarefoundations}} 
from strings to cvalues. The store is implemented as a total map, which is a
map that returns a default value when a key is requested that is not present in
the map. Values can be added to the map via the \coq{t_update }
function.

We could also have used a partial map. Partial maps instead return an option,
the Coq equivalent of our Maybe, instead of the basic type.
Returning the default None value would be akin to throwing an exception.
% maybe explain why I didn't use a partial map?

\begin{listing}
\begin{minted}{coq}
Definition store := total_map cvalue.

Definition t_update {A:Type} (m : total_map A)
                    (x : string) (v : A) :=
  λ x', if beq_string x x' then v else m x'.

\end{minted}
\end{listing}

\subsubsection{Do notation}
The interpreters make excessive use of the bind function of the monads.
Because of this, we introduce a special notation for the function.

\begin{listing}
\begin{minted}{coq}
Notation "x '<<' y ; z" := (bind y (λ x, z))
  (at level 20, y at level 100, 
   z at level 200, only parsing).
\end{minted}
\end{listing}

If we did not include this notation, making use of the Monad would quickly
become cumbersome. With it, we are able to write data pipelines in an
imperative style. To illustrate, the below code shows the two
different styles. As the length of the `imperative' program increases, the
functional notation grows more cumbersome and error prone due to the number of
parenthesis involved.

\begin{listing}
\begin{minted}{coq}
Example do_notation :=
	v << (eval_expr e) ;
	b << (ensure_bool v) ;
	returnM (VBool (negb b)).

Example nested_notation :=
	(eval_expr e) >>= (λ v,
		(ensure_bool v) >>= (λ b,
			returnM (VBool (negb b)))).
\end{minted}
\end{listing}

\subsubsection{The interpreter}
As shown in Section~\ref{sec:lang} the syntax of the language allows the two
types of values, booleans and natural numbers, to be used interchangably while
still have a valid syntax. However, most operations will be meaningless if used
on the wrong operators. For example, ``1 + true'' is valid syntax, but it is 
not a valid program.

To ensure that the correct types are used when evaluating operators,
the interpreter has an `ensure' function. for each of the types. 
Using the \coq{project } function from the \coq{SubType } class, we can see if
the provided value if of the desired type.

\begin{minted}{Coq}
Definition ensure_type (subType : Type)
  {M : Type → Type} {MM : Monad M} {MF : MonadFail M} 
  {valType : Type}
  {ST : SubType subType valType}
  (n : valType) : M subType :=
  match project n with
  | Some x =>  returnM x
  | None => fail
  end.
\end{minted}

Notice that both ensure functions are parametrized over a monad M that is
capable of failing. This allows us to resuse these functions with whatever
stack of monad transformers we desire, as long as one of those monad
transformers adds the ability to fail e.g., MaybeT is on the stack or Maybe is
the inner-most monad.

When the ensure function is called with a type other than the desired type, it
returns the fail value of its monad M. As a consequence of the
fail\_left lemma, this failure is propagated throughout the rest of the
program. This allows us to model the interpreter crashing if the program is not
well-typed.

\begin{listing}[H]
\begin{minted}{Coq}
Fixpoint eval_expr (e : expr) : M cvalue :=
  match e with
  | EVal x => returnM (inject x)
  | EVar x => st << get ;
      returnM (st x)
  | EPlus e1 e2 => 
      v1 << (eval_expr e1) ;
      v2 << (eval_expr e2) ;
      n1 << (ensure_type nat v1) ;
      n2 << (ensure_type nat v2) ;
      returnM (inject (n1 + n2))
  | EMult e1 e2 =>
      v1 << (eval_expr e1) ;
      v2 << (eval_expr e2) ;
      n1 << (ensure_type nat v1) ;
      n2 << (ensure_type nat v2) ;
      returnM (inject (n1 * n2))
  | EEq e1 e2 =>
      v1 << (eval_expr e1) ;
      v2 << (eval_expr e2) ;
      n1 << (ensure_type nat v1) ;
      n2 << (ensure_type nat v2) ;
      returnM (inject (Nat.eqb n1 n2))
  | ELe e1 e2 =>
      v1 << (eval_expr e1) ;
      v2 << (eval_expr e2) ;
      n1 << (ensure_type nat v1) ;
      n2 << (ensure_type nat v2) ;
      returnM (inject (Nat.leb n1 n2))
  | ENot e =>
      v << (eval_expr e) ;
      b << (ensure_type bool v) ;
      returnM (inject (negb b))
  | EAnd e1 e2 =>
      v1 << (eval_expr e1) ;
      v2 << (eval_expr e2) ;
      b1 << (ensure_type bool v1) ;
      b2 << (ensure_type bool v2) ;
      returnM (inject (andb b1 b2))
  end.
\end{minted}
\end{listing}

The concrete interpreter follows the same structure for each kind of operator.
The smaller expressions are evaluated first via recursive calls to the
evaluation function and the interpreter
ensures they are of the proper types. Then, the built-in operator corresponding
to the expression is called on those values.

\begin{listing}[H]
\begin{minted}{Coq}
Fixpoint ceval {M} `{MonadExcept M, MonadState M} (c : com) : M unit :=
  match c with
  | CSkip => returnM tt
  | c1 ;c; c2 => 
      (ceval c1) ;; (ceval c2)
  | x ::= a => 
      n << (eval_expr a) ;
      st << get ;
      put (t_update st x n)
  | CIf b c1 c2 => 
      v << (eval_expr b) ;
      b' << (ensure_type bool v) ;
      if b' (ceval c1) (ceval c2)
  | try c1 catch c2 =>
   	  catch (ceval c1) (ceval c2)
  | CFail => fail
  end.
\end{minted}
\caption{The concrete interpreter for statements}
\label{lst:concrete_statements}
\end{listing}

The ceval function is the concrete interpreter of our language. It requires
that the monad M that is used is an instance of both MonadExcept and
MonadState. This gives us access to get, put, catch and fail, which we need for
variables and exceptions.

\section{Galois Connections}
In this section we will describe the notion of Galois
connections~\cite{cousot1992comparing}. 
Before we do
so, we will take a quick detour to preordered sets. We define type classes for
preordered sets and define monotonicity before moving on to define a type 
class for Galois connections.

\subsection{Preordered sets}
The first definition we shall implement is the notion of a preordered set. 
A preordered set is any set S on which we can define a preorder relation
\coq{⊑ } such that the preorder relation is reflexive and transitive. That
is, for all \coq{a, a ⊑ a } (reflexivity) and for all \coq{a b c }, if 
\coq{a ⊑ b } and \coq{b ⊑ c }, then \coq{a ⊑ c } (transitivity).
We refer to such a combination of set S and relation as \coq{(A, ⊑) }.

The definitions of reflexive and transitive relations are already included in
the standard library of Coq, so we can import those. This gives us the
following definition of the preorderd set as a Coq type class.

\begin{listing}
\begin{minted}{Coq}
Class PreorderedSet (A : Type) : Type :=
{
  preorder : A → A → Prop;
  preorder_refl: Reflexive preorder;
  preorder_trans: Transitive preorder;
}.
Infix "⊑" := preorder (at level 40).
\end{minted}
\end{listing}

In addition, we introduce the notation ⊑ to denote a preorder.

\subsubsection{Galois connections}
We require the definition of a preordered set in order to be able to define a
Galois connection.

Traditionally, Galois connections are defined on two partially ordered sets.
However, they can also be defined on preordered sets, and for our purposes that
works too. 
The difference between preordered sets and partially ordered sets is
that a partial order is antisymmetric in addition to reflexive and transitive.
We do not require the antisymmetric property, so we can loosen that restraint.

The definition of Galois connections that we have implemented is that of the
monotone Galois connection. Given two preordered sets \coq{(A,⊑) } and
\coq{(B,⊑) }, a Galois connection between those two sets is defined as two
functions \coq{α : A -> B } and \coq{γ : B -> A } such that 
\coq{α a ⊑ b } iff \coq{a ⊑ γ b }.

\begin{minted}{Coq}
Class Galois (A A' : Type) : Type := γ : A -> ℘ A'.
\end{minted}

Instancing the Coq type class definition of Galois connections between two
types \coq{A } and \coq{B } requires supplying those types, as well as a gamma 
function \coq{γ : B -> A -> Prop }.

Note that the Coq definition does not require \coq{A' } to be a preordered set. 
This is because we actually consider Galois connections between 
\coq{A } and \coq{℘ A' }. For example, we will consider the relation between 
parities like even and sets of natural numbers e.g.\ \coq{{2, 4, 8} }.

Another difference between the Coq implementation and the mathematical
definition is the lack of corresponding \textit{alpha} function. This is
because we are unable to define this function, due to limitations in Coq.
Luckily, it turns out that the \coq{α } function is not necessary to prove
soundness~\cite{jourdan2016verasco}.

It is difficult to grasp what a Galois connection means from the definition
alone, so we will provide a few examples in the next section, after
introducing the abstract types.

\subsubsection{Parities}
The first abstract type we define is \coq{Parity }.

\begin{listing}
\begin{minted}{Coq}
Inductive parity : Type := par_even | par_odd.
\end{minted}
\end{listing}

The parity of a natural number is whether it is even or odd; e.g.\ the parity
of the number 2 is even, and the parity of the number 9 is odd. 

We can define a Galois connection between natural numbers and the parity type.
To do so, we must provide a gamma function and prove its monotonicity. Recall
that the signature is of the form \coq{A -> A' -> Prop }. In this
case, we shall use \coq{parity } as \coq{A' } and \coq{nat } as \coq{A }.

Any type of the form \coq{A' -> Prop } can be seen as sets of \coq{A' }. We define
a function \coq{gamma_par } as taking a parity as a parameter and returning
sets of natural numbers.

\begin{listing}
\begin{minted}{Coq}
Inductive gamma_par : parity → ℘ nat :=
  | gamma_par_even : ∀ n, Nat.Even n → gamma_par par_even n
  | gamma_par_odd  : ∀ n, Nat.Odd n → gamma_par par_odd n.
\end{minted}
\end{listing}

In the provided code, the even and odd symbols are imported from the Coq
standard library. They are the sets of even and odd numbers respectively. Each
of the three possible values of parity is mapped to a set of natural numbers.

\begin{listing}
\begin{minted}{Coq}
Instance galois_parity_nat : Galois nat parity :=
{
  gamma := gamma_par;
  gamma_monotone := gamma_par_monotone;
}.
\end{minted}
\end{listing}

The above code shows how a Galois connection between sets of natural numbers 
and parities is instantiated. \coq{gamma_par_monotone } refers to the proof the
the \coq{gamma_par } function is monotone. This proof has been omitted for 
brevity.

\subsubsection{Intervals}
Parities are only one possible abstraction of natural numbers. Another
possibility would be to use intervals. In this section, we describe the
implementation of intervals using dependent records.

An interval of natural numbers is a valid abstraction of a set of natural
numbers if each of the natural numbers in the set falls within the interval.
For example, the the interval \coq{[1,5] } is an abstract approximation of the set
\coq{{2, 4, 5} }. It is also a valid approximation of the set \coq{\{1,5\} }. 
This again illustrates the fact that the abstract approximation often lose 
precision.

The same operators than can be defined on natural numbers can be defined on
intervals. Addition, multiplication and comparisons can all be implemented.
Adding the intervals \coq{[1,3] } and \coq{[4, 7] }  would result in the 
interval \coq{[5, 10] }, for example. Whenever we define an interval, we also need to provide a
proof that the mininum end of the interval is less than the maximum end. This
is represented in the record by the \coq{min_max } field.

\begin{listing}
\begin{minted}{coq}
Record interval := Interval {
  min: nat;
  max : nat;
  min_max : min <= max;
}.

Inductive gamma_interval : interval → ℘ nat :=
  | gamma_interval_cons : ∀ i n, 
      preorder (min i) n → preorder n (max i) →
      gamma_interval i n.
\end{minted}
\end{listing}

\subsubsection{Abstract Booleans}
The abstract booleans are only slightly different from their concrete
counterpart. We supplement the normal boolean values (true and false) with
a value for top. As with the parities, the abstract value ab\_top
represent both concrete values.

\begin{minted}{coq}
Inductive abstr_bool : Type := ab_true | ab_false.
\end{minted}

\begin{minted}{coq}
Definition gamma_bool (ab: abstr_bool) : ℘ bool :=
  match ab with
  | ab_true   => λ b, Is_true b
  | ab_false  => λ b, ~Is_true b
  end.
\end{minted}

The gamma function for booleans is straightforward due to the limited
number of concrete values. 

\section{The Abstract Interpreter}
We again define the interpreter in a monad-agnostic way. We require the
used monad to have the same capabilities as the one in the concrete
interpreter, namely failing and state.

The abstract state differs from the concrete state in what values, and with
those, what type of store is
used. The abstract store is almost the same is the concrete store, but returns
abstract values instead of concrete values. When concrete values are inserted
in the store, they are first converted into their abstract counterpart via the
extract function.

%We can perform different types of abstract analysis by providing different
%types as the abstract value. The type inference of our SubType system will
%select the right instances. For example, we can perform parity analysis by
%using \coq{Definition avalue := (parity+abstr_bool). } and interval analysis by
%using \coq{Definition avalue := (interval+abstr_bool). }}.

In the abstract interpreter example below, we use the following definition for
avalue \coq{Definition avalue := (parity+abstr_bool)%type }. 

\begin{listing}[H]
\begin{minted}{coq}
Fixpoint eval_expr_abstract {M} {ME : MonadExcept M} {MS : MonadState M} 
    (e : expr) : M avalue :=
  match e with
  | EVal x => returnM (inject x)
  | EVar x => st << get ;
      returnM (st x)
  | EPlus e1 e2 => 
      v1 << (eval_expr_abstract e1) ;
      v2 << (eval_expr_abstract e2) ;
      n1 << (ensure_par v1) ;
      n2 << (ensure_par v2) ;
      returnM (inject (parity_plus n1 n2))
  | EMult e1 e2 =>
      v1 << (eval_expr_abstract e1) ;
      v2 << (eval_expr_abstract e2) ;
      n1 << (ensure_par v1) ;
      n2 << (ensure_par v2) ;
      returnM (inject (parity_mult n1 n2))
  | EEq e1 e2 =>
      v1 << (eval_expr_abstract e1) ;
      v2 << (eval_expr_abstract e2) ;
      n1 << (ensure_par v1) ;
      n2 << (ensure_par v2) ;
      returnM (inject (parity_eq n1 n2))
  | ELe e1 e2 =>
      v1 << (eval_expr_abstract e1) ;
      v2 << (eval_expr_abstract e2) ;
      n1 << (ensure_par v1) ;
      n2 << (ensure_par v2) ;
      returnM (inject (ab_top))
  | ENot e =>
      v << (eval_expr_abstract e) ;
      b << (ensure_abool v) ;
      returnM (inject (neg_ab b))
  | EAnd e1 e2 =>
      v1 << (eval_expr_abstract e1) ;
      v2 << (eval_expr_abstract e2) ;
      b1 << (ensure_abool v1) ;
      b2 << (ensure_abool v2) ;
      returnM (inject (and_ab b1 b2))
  end.
\end{minted}
\end{listing} 

The abstract interpreter for expressions looks much the same as the concrete
version. The difference is that the operations on the types are now the 
abstract versions. For example,
where the concrete interpreter called the standard plus operator for natural
numbers, the abstract interpreter calls the parity or interval plus function.

\subsubsection{The optionA monad}
Thus far, we have seen the fail method of option used to model crashed programs
due to type mismatches, for exampling when adding two booleans, or a boolean
and a natural number.
In our language, we also wish to model exceptions. Consider the following 
Java snippet.

\begin{minted}{java}
if (x == 0) {
    throw new Exception();
else {
    x = 3;
}
\end{minted}

We could try to model such a program with just the \coq{None } value of option. 
This proves insufficient when this program is interpreted in an abstract way, 
because an abstract interpreter might be uncertain whether \coq{x } is equal to 
\coq{0 } or not and has to reflect this in the returned value.

We introduce the monad optionA~\cite{keidel2018compositional} 
to capture this side effect.

\begin{minted}{coq}
Inductive optionA (A : Type) : Type :=
| NoneA : optionA A
| SomeA : A → optionA A
| SomeOrNoneA : A → optionA A.
\end{minted}

In addition to constructors modeling successful and failed operations, this
type has a constructor that models uncertainty as to whether the operation has
succeeded.

As with all abstract types, we need an ordering and a gamma connection. We
define a lattice with \coq{SomeOrNoneA } as the top element. \coq{NoneA } and
\coq{SomeA } correspond to \coq{None } and \coq{Some }, which we see reflected
in the gamma function in Listing \ref{lst:gamma_optionA}.

\begin{minted}{coq}
Inductive optionA_le : optionA A → optionA A → Prop :=
  | optionA_le_none : optionA_le NoneA NoneA
  | optionA_le_none_justornone : ∀ y, optionA_le NoneA (SomeOrNoneA y)
  | optionA_le_just : ∀ x y, preorder x y → optionA_le (SomeA x) (SomeA y)
  | optionA_le_justornone_r : ∀ x y, preorder x y →
      optionA_le (SomeA x) (SomeOrNoneA y)
  | optionA_le_justornone : ∀ x y, preorder x y → 
      optionA_le (SomeOrNoneA x) (SomeOrNoneA y).
\end{minted}

\begin{listing}
\begin{minted}{coq}
Inductive gamma_optionA {A A'} {GA : Galois A A'} : optionA A → option A' → Prop :=
  | gamma_noneA : gamma_optionA NoneA None
  | gamma_SomeornoneA_none : ∀ a, 
      gamma_optionA (SomeOrNoneA a) None
  | gamma_SomeA_Some : ∀ a' a, γ a' a → gamma_optionA (SomeA a') (Some a)
  | gamma_Someornone_Some : ∀ a' a, 
      γ a' a →
      gamma_optionA (SomeOrNoneA a') (Some a).
\end{minted}
\caption{Gamma function for optionA}
\label{lst:gamma_optionA}
\end{listing}

As with Maybe, we have monad transformer that adds this functionality to a
monad. We call this transformer MaybeAT, and we define it as \\
\coq{Definition optionAT M A := M (optionA A). }

\section{Extracting the Shared Interpreter}\label{sec:shared_interpreter}
As observed in the previous section, the abstract and concrete interpreter
share many similarities. This leads us to the question of whether we can
decompose the interpreters along the shared structure in a way that eases the
proof burden. In this section, we look at how we have extracted the shared
interpreter and how this shared structure can be instantiated to create
abstract and concrete interpreters like those defined earlier.

\subsection{IsBool and IsNat}
The shared interpreter needs to have a uniform way of handling values, as it
can be instantiated with either abstract or concrete values. For every type of
concrete value we will require a corresponding interface. In our case, this
means that we will require an interface for boolean types and an interface for
numerical types.

\begin{minted}{Coq}
Class IsBool (M : Type → Type)
  (valType boolType : Type) : Type :=
{
  ensure_bool  : valType → M boolType;
  build_bool   : boolType → M valType;
  extract_bool : bool → M boolType;
  and_op       : boolType → boolType → M boolType;
  neg_op       : boolType → M boolType;
  if_op        : boolType → M unit → M unit → M unit;
}.
\end{minted}

The IsBool typeclass is the interface for the boolean types. The interface
exposes all the operators that are possible on booleans. We've defined the and
operator and the negation operator. We also include the if operator in this
interface, as the behaviour of if will change depending on the boolean type. 

In addition, there are also the ensure, build and extract functions. The ensure
function checks whether the supplied value is actually of the type the
typeclass is instantiated for. If not, the program will crash. This ensure
function is called before the aforementioned operators, as they are not defined
for natural numbers. The build function wraps a boolean type in the value type
so that it can be passed along into other functions. The extract function can
turn a concrete value into a boolType. In the concrete implementation
of the IsBool typeclass, this will be the identity function.

\begin{minted}{Coq}
Definition ensure_abool {M} `{MonadFail M} 
    (v : avalue) : M abstr_bool :=
  match v with
  | VAbstrBool b => returnM b
  | _ => fail
  end.

Definition eval_if_abstract {M} `{MonadFail M} 
    {A} `{Joinable A} 
    (b : abstr_bool) (st1 st2 : M A) : M A :=
  match b with
  | ab_true   => st1
  | ab_false  => st2
  | ab_top    => join_op st1 st2
  end.

Definition extract_ab (b : bool) : abstr_bool := 
  match b with
  | true => ab_true
  | false => ab_false
  end.

Instance abstract_boolean_type {M} `{MonadFail M} : 
  IsBool M avalue abstr_bool :=
{
  ensure_bool := ensure_abool;
  extract_bool := extract_abM;
  build_bool := build_abool;
  and_op := and_abM;
  neg_op := neg_abM;
  if_op := eval_if_abstract;
}.
\end{minted}

The above listing shows the abstract implementation of the IsBool typeclass.
The abstract if evaluation takes two monadic values and returns one based on the
given boolean value. In the case of the Top boolean value, it returns a join of
the two states, as the abstract interpreter will be unsure of what path to
take. The listing also shows how the extract function takes a concrete value
and turns it into the correct abstraction.

\begin{minted}{Coq}
Class IsNat (M : Type → Type)
  (valType boolType natType : Type) : Type :=
{
  ensure_nat  : valType → M natType;
  build_nat   : natType → M valType;
  extract_nat : nat → M natType;
  plus_op     : natType → natType → M natType;
  mult_op     : natType → natType → M natType;
  eq_op       : natType → natType → M boolType;
  le_op       : natType → natType → M boolType;
}.
\end{minted}

The typeclass for numerical types looks much the same. It has the same ensure,
build and extract functions, as well as the operators for numerical types;
addition multiplication, equality and less-than.

Using the above interfaces, we can define the shared interpreter.
\begin{minted}{Coq}
Definition extract_build_val 
    {M : Type → Type} 
    {valType boolType natType : Type}
    `{M_monad : Monad M, 
      nat_inst : IsNat M valType boolType natType, 
      bool_inst : IsBool M valType boolType}
    (v : cvalue) : M valType :=
  match v with
  | VNat n => n' <- extract_nat n; build_nat n'
  | VBool b => b' <- extract_bool b; build_bool b'
  end.

Fixpoint shared_eval_expr 
    {M : Type → Type} {valType boolType natType : Type}
    `{M_monad : Monad M, 
      store_inst : MonadState (total_map valType) M,
      nat_inst  : IsNat M valType boolType natType, 
      bool_inst : IsBool M valType boolType}
    (e : expr) : M valType :=
  match e with
  | EVal v =>
      extract_build_val v
  | EVar x =>
      s <- get;
      returnM (s x)
  | EPlus e1 e2 => 
      v1 <- shared_eval_expr e1 ;
      v2 <- shared_eval_expr e2 ;
      n1 <- ensure_nat v1 ;
      n2 <- ensure_nat v2 ;
      n <- plus_op n1 n2 ;
      build_nat n
  | EMult e1 e2 => 
      v1 <- shared_eval_expr e1 ;
      v2 <- shared_eval_expr e2 ;
      n1 <- ensure_nat v1 ;
      n2 <- ensure_nat v2 ;
      n <- mult_op n1 n2 ;
      build_nat n
  | EEq e1 e2 =>
      v1 <- shared_eval_expr e1 ;
      v2 <- shared_eval_expr e2 ;
      n1 <- ensure_nat v1 ;
      n2 <- ensure_nat v2 ;
      b <- eq_op n1 n2 ;
      build_bool b
  | ELe e1 e2 =>
      v1 <- shared_eval_expr e1 ;
      v2 <- shared_eval_expr e2 ;
      n1 <- ensure_nat v1 ;
      n2 <- ensure_nat v2 ;
      b <- le_op n1 n2;
      build_bool b
  | ENot e1 =>
      v1 <- shared_eval_expr e1 ;
      b1 <- ensure_bool v1 ;
      b <- neg_op b1;
      build_bool b
  | EAnd e1 e2 =>
      v1 <- shared_eval_expr e1 ;
      v2 <- shared_eval_expr e2 ;
      b1 <- ensure_bool v1 ;
      b2 <- ensure_bool v2 ;
      b <- and_op b1 b2 ;
      build_bool b
  end.
  
Fixpoint shared_ceval 
  {M : Type → Type} {valType natType boolType : Type}
  `{M_fail : MonadFail M, 
    store : MonadState (total_map valType)  M, 
    M_except : ∀ A, MonadExcept M A, 
    nat_inst : IsNat M valType boolType natType, 
    bool_inst : IsBool M valType boolType}
  (c : com) : M unit :=
  match c with
  | CSkip => returnM tt
  | c1 ;c; c2 =>
      (shared_ceval c1) ;; (shared_ceval c2)
  | x ::= a => 
      v <- shared_eval_expr a ;
      s <- get ;
      put (t_update s x v)
  | CIf b c1 c2 => 
      v <- shared_eval_expr b ;
      b' <- ensure_bool v ;
      if_op b' (shared_ceval c1) (shared_ceval c2)
  | TRY c1 CATCH c2 => 
      catch (shared_ceval c1) (shared_ceval c2)
  | CFail => fail
  end.
\end{minted}

The required instances are added as implicited contraints to the definitions of
the shared interpreter. By doing this, we can get the type engine of Coq to
infer the required instances for us. This greatly simplifies how we can now
define the abstract and concrete interpreters. We only need to supply the
desired monad and the desired abstraction.

\begin{minted}{Coq}
Definition ConcreteState := MaybeT (StateT store Maybe).

Definition AbstractState := 
  MaybeAT (StateT abstract_store Maybe).

Definition conrete_interpreter (c : com) : ConcreteState Abstractstate :=
  shared_ceval c.

Definition abstract_interpreter (c : com) : AbstractState unit :=
  shared_ceval (nat_inst:=isnat_parity _) c.
\end{minted}

We only have to define which State monad we want the interpreter to use.
Because the State type uses concrete types, it automatically infers that we
will also require the concrete instances of the Except, Store, IsBool and IsNat
typeclasses. In the next section, we shall discuss how defining the abstract
and concrete interpreters as implementations of the shared interpreter aids in
proving the soundness of the abstract interpreter.

\section{Soundness}\label{sec:soundness}
The main focus of this thesis is the soundness of the abstract interpreter. In
this section, we will define what it means for an abstract function to be sound
with regards to a concrete function, and show how we prove the abstract 
interpreter is sound with regards to the concrete interpreter. 

Our definition of sound is analogue to our definition of gamma: a abstract 
function is sound if its output approximates the output of a concrete function,
provided the inputs of the abstract function approximated the inputs of the
concrete function.

For example, \textbf{if} we have two functions \coq{f : A -> B } and \coq{f' 
: A' -> B' }, where there are two Galois connections 
between \coq{A } and \coq{A' }, and \coq{B } and \coq{B' } respectively, 
\textbf{then} when 
there is a gamma relation between the input values, there will be a gamma
relation between the output values.

This is a bit of an obtuse definition, so we will provide some examples. Let us
look at the soundness of the parity plus function. We will show what it
means for that function to be sound with regards to standard addition of
natural numbers.

\begin{minted}{Coq}
Definition parity_plus (p q : parity) : parity :=
  match p with 
  | par_top => par_top
  | par_even => q
  | par_odd => match q with
               | par_top => par_top
               | par_even => par_odd
               | par_odd => par_even
               end
  end.
\end{minted}

So in more concrete terms, the function \coq{parity_plus } is sound with 
regards to \coq{plus }
if when, if the inputs are related, the output is also related. In Coq, this 
notion of relatedness is written as follows

\begin{minted}{Coq}
Lemma parity_plus_sound : ∀ p1 p2 n1 n2, 
    gamma p1 n1 → gamma p2 n2 → 
    gamma (parity_plus p1 p2) (plus n1 n2).
\end{minted}

If \coq{p1 } is an abstract representation of \coq{n1 }, and \coq{p2 } is an 
abstract representation of \coq{n2 }, then \coq{parity_plus p1 p2 } should be an 
abstract representation of \coq{plus n1 n2 }. 

Due to the automation capabilities of Coq, the actual proof for the soundness
of the \coq{parity_plus } function is very short.

\begin{minted}{Coq}
Proof. 
  autounfold with soundness. repeat constructor. intros.
  destruct p1, p2; eauto with soundness.
Qed.
\end{minted}

The proof is written using case analysis. It considers all possible
constructors of the parities and simplies the result of the \coq{parity_plus }
function. Then it uses the lemmas from the standard libraries of adding 
combinations of even and odd numbers to solve the subgoals.

We have similar proofs for each of the operations on values. We will not list
all those proofs here, as they are all short and of similar structure. Examine
all possible input values; resolve the functions and ascertain the preservation
of the gamma relation in those cases where the hypotheses hold.

More interesting are the soundness proofs for the interpreters. Because the
abstract and concrete interpreters both consist of the same structure, the
shared interpreter, the interpreters can be decomposed along the same lines.

As discussed in Section~\ref{sec:monads}, we can decompose the program along
the lines of the bind methods. If we can proof that the bind methods of our
chosen monads are sound and that the functions called by the bind methods are
sound, than the entire interpreter is sound. 

By repeating the application of the soundness lemma of bindM, 
we can turn a goal concerning a series of binds into a series of subgoals, each
concerning only a pair of functions. These pairs will correspond to each of the
functions we've already proven the soundness of, such as \coq{parity_plus }, or
methods from the MonadExcept and MonadState typeclasses.

\begin{minted}{Coq}
Theorem eval_expr_sound : ∀ a,
  gamma (eval_expr_abstract a) (eval_expr a).
Proof.
  intros. unfold eval_expr_abstract, eval_expr. induction a; 
  repeat solve_binds; auto with soundness. 
Qed.

Theorem sound_interpreter:
  ∀ c, gamma (ceval_abstract c) (ceval c).
Proof.
  intros. unfold ceval_abstract, ceval. 
  induction c; simpl; repeat solve_binds; auto with soundness.
Qed.
\end{minted}

\subsection{Sample Programs}
Now that we have a proof of the soundness of the abstract interpreter for every
statement in the language, we will take a look at three concrete examples of a
program written in the language. 

\begin{minted}{Coq}
Definition program1 := 
  IF2 (ELe (EVal (VNat 5)) (EVal (VNat 4))) 
  THEN (CAss "x" (EVal (VBool true))) 
  ELSE (CAss "x" (EVal (VNat 9))).

Definition program2 :=
  CAss "x" (EVal (VNat 20)) ;c;
  IF2 (EEq (EVar "x") (EVal (VNat 10)))
  THEN CFail
  ELSE (CAss "x" (EVal (VNat 20))).

Definition program3 :=
  CAss "x" 
  	(EPlus (EVal (VNat 10)) (EVal ((VBool true)))).
\end{minted}

In more conventional notation, these programs correspond to

\begin{lstlisting}
IF 5 < 4 THEN x := true ELSE x:= 9
\end{lstlisting}

\begin{lstlisting}
x := 20; IF x == 10 THEN fail ELSE x:= 20
\end{lstlisting}

\begin{lstlisting}
x := (10 + true)
\end{lstlisting}

We will discuss how the two interpreters work through these programs. When the
concrete interpreter evaluates the first program, it is able to tell that 5 is
not less than 4. As such, it evaluates the first branch of the if statement and
ignores the second. As such, it will end up with a store that contains
\coq{true } as the value of \coq{x }.

In contrast, the abstract interpreter, when using parities, extracts the 
abstract values for 5 and 4
and will end up with an if statement that compares the set of odd numbers with
the set of even numbers. It is unable to determine which of these is smaller
than the other so it evaluates to the top value for the abstract booleans. In
this case, it joins the stores of the two branches and this results in a store
with the abstract top value for \coq{x }. The concrete value of \coq{true } is
sound with regards to this top value, and so the abstract interpreter is sound
for the first program.

In the case of the second program, the concrete interpreter will opt for the
else branch and return a store where x holds the value of 20. The abstract
interpreter again cannot determine whether the values are equal and results in
the top abstract boolean value. It returns a state that is a join between the
failed state and a result where x is 20, using the ExceptionOrReturn
constructor. This value is a valid approximation of the concrete result, so the
interpreter is again sound.

In the third program, both the abstract and concrete interpreter exhibit the
same behaviour. Because adding a boolean to an integer is illegal, both
interpreters crash on that expression. Any concrete state is approximated by
the crashed abstract state, including a crashed concrete state, so the
interpreter is sound when analyzing this program.

Of course, these examples have been simplified for clarity. A more advanced
implementation would be able to combine information from multiple abstractions,
such as intervals and parities, to correctly infer the path. 

