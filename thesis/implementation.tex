\chapter{Implementation}
In this chapter we will describe how the framework is implemented in Coq and
the theory behind the implementation. First, in Section \ref{sec:monads} 
we will delve into the theory
behind monads~\cite{wadler1995monads}. We borrow these constructs from the 
Haskell Prelude and reimplement them in Coq. We also leverage the ability of
Coq to directly add laws to our definitions. This makes it impossible for us to
define invalid monads. Secondly, in Section \ref{sec:concrete} we shall describe the 
syntax of a toy language and define a concrete interpreter of this language. We
will show how we can decompose the concrete interpreter due to its monadic
structure. After that, we dive into the theory behind Galois connections. 
After defining Galois connections, we show how there is a Galois connection
between the previously defined concrete interpreter and an example of an
abstract interpreter.
In Section~\ref{sec:soundness}, we show what it means for such an abstract
interpreter to be sound. 

\section{Monads}~\label{sec:monads}
Many tutorials explaining monads exist and monads are generally regarded as
difficult to understand~\cite{petricek2018we}. We will briefly try to explain
them here, though a complete understanding monads is not neccessary to follow 
later sections. Understanding that we can decompose the program along the 
lines of the methods provided by the Monad typeclass is sufficient.

Monads are a way to add impure effects to a pure language. Examples of impure
effects are modifying a global state, throwing and handlings exceptions and
perform IO operations. A Computer Science course~\cite{upenn_monads} at the University of
Pennsylvania likens monads to a recipe, a description of steps to take. Such
descriptions are values themselves, which makes using monads pure.

In Coq we can implement monads in the form of a typeclass~\cite{sozeau2008first}, 
as it is done in Haskell~\cite{wadler1995monads}. Typeclasses are somewhat like interfaces in 
object-oriented programming languages. A programmer can write functions 
operating on typeclasses instead of concrete types, and those functions can
accept all types that implement the functions defined in that specific typeclass. 
In this case, all types belonging to the Monad typeclass must implement two functions,
\textit{bind}, originally called \textit{*} in the paper by Wadler, and 
\textit{return}, originally called \textit{unit}. An implementation of monads
as a typeclass in Coq is given in Listing \ref{lst:sample_monad}.

\begin{minted}{Coq}
Class Monad (M : Type → Type) : Type :=
{
  returnM : ∀ {A}, A → M A;
  bindM : ∀ {A B}, M A → (A → M B) → M B;
}.
Notation "m >>= f" := (bindM m f) (at level 40, left associativity).
\end{minted}

Because return is a reserved keyword in Coq, we rename both \coq{return } and 
\coq{bind } into \coq{returnM } and \coq{bindM } respectively.
\coq{returnM } takes a value and \"wraps\" it in the monad. \coq{bindM } is
a function that can apply a function to a monadic value. As is the convention
in Haskell, we will use \coq{>>= } as an infix notation for the bindM
function.

One of the advantages that Coq typeclasses have over those in Haskell is the
abilty to add lemmas to the typeclass in addition to the methods. Proper monads
have to observe three laws, together called the Monad laws. These laws are, as
written in the original paper
\begin{align*}
    \textit{unit}\ a >>= \lambda b. n =&\ n[a/b] \\
    m >>= \lambda a . \textit{unit}\ a =&\ m \\
    m >>= (\lambda a.n >>= \lambda b.o) =&\ (m >>= \lambda a.n) >>= \lambda b.o
\end{align*}

In English, these mean that binding \coq{returnM } to a function f is
equivalent to just applying $f$ to the value wrapped by \coq{returnM }. The
second law states that binding to \coq{returnM } is effectively a no-op, and
the last law requires \coq{bindM } to be associative. In Coq, we can add the
following lemmas to the Monad typeclass to ensure that all typeclass instances
are valid monads, which is something that Haskell cannot guarantee. 

\begin{listing}[H]
\begin{minted}{Coq}
Class Monad (M : Type → Type) : Type := {
  bind_id_left : ∀ {A B} (f : A → M B) (a : A), 
    bindM (returnM a) f = f a;
  bind_id_right : ∀ {A} (m : M A),
    bindM m returnM = m;
  bind_assoc : ∀ {A B C} (m : M A) (f : A → M B) (g : B → M C),
    bindM (bindM m f) g = bindM m (λ a, bindM (f a) g);
}
\end{minted}
\caption{Lemmas for the monad laws}
\label{lst:monad_lemmas}
\end{listing}

In this thesis, we consider monads that add two different side effects. The
first is the Maybe monad, also known as option in the Coq standard libarry. 
The Maybe monad adds the
possibility of failure to an operation. The other is the State monad, which
allows us to keep track of a global state. In the next few sections we will
discuss the implementation of these monads.

\subsection{Maybe}
\begin{minted}{coq}
Inductive Monad A : Type :=
    | Just : A → Maybe A
    | Nothing : Maybe A.
\end{minted}

The first monad we implemented was the Maybe monad. Values of the type
\mintinline{coq}{Maybe A } can be of either the form 
\mintinline{coq}{Just a }, where $a$ is a value of type $A$ or 
\mintinline{coq}{Nothing }. Here, \coq{None } represent a failed
computation. For example, a monadic version of division \coq{nat →
nat → Maybe nat } could return \coq{None } when dividing by zero,
and a \coq{Just } value with the right answer in other cases.

The return method of \coq{Maybe } is the same as the \coq{Just } constructor. 
The \coq{bindM } method of the \coq{Maybe } monad performs a case analysis on the provided
value. In the case of \coq{Just }, it extracts the inner value and applies the given
function to it. In the case of \coq{None }, it returns \coq{None }. This allows the chaining
of multiple operations without explicit error handling between each step.

\begin{minted}{coq}
  Definition bind_maybe {A B} 
  (m : Maybe A) (k : A → Maybe B) : Maybe B :=
    match m with
    | None => None
    | Just a => k a
    end
\end{minted}

Because we can use \coq{Just } as the \coq{returnM } method of \coq{Maybe }, we
can now move on to proven the monadic laws. These laws require that
\coq{returnM } is a left and right identity for \coq{bind }, and that \coq{bind
} is associative. If we've proven this, we can combine those three lemma's
together with the definition of \coq{bind_maybe } and \coq{Just } into an
instance for the \coq{Monad } typeclass. The Coq code for this can be seen in
Listing \ref{lst:monad_maybe}. Note that the proofs have been omitted for
brevity.

\begin{listing}
\begin{minted}{coq}
  Lemma bind_maybe_id_left : ∀ {A B} (f : A → Maybe B) (a : A), 
    bind_maybe (Just a) f = f a.
  Admitted.

  Lemma bind_maybe_id_right : ∀ {A} (m : Maybe A), 
    bind_maybe m Just = m.
  Admitted.

  Lemma bind_maybe_assoc : ∀ {A B C} (m : Maybe A) 
    (f : A → Maybe B) (g : B → Maybe C),
  bind_maybe (bind_maybe m f) g = bind_maybe m (λ a : A, bind_maybe (f a) g).
  Admitted.

  Global Instance monad_maybe : Monad Maybe :=
  {
    returnM := Just;
    bindM := bind_maybe;
    bind_id_left := bind_maybe_id_left;
    bind_id_right := bind_maybe_id_right;
    bind_assoc := bind_maybe_assoc;
  }. 
\end{minted}
\caption{Instance of the Monad typeclass for Maybe}
\label{lst:monad_maybe}
\end{listing}

\subsection{State}
When we evaluate a program, we will require a way to keep track of a global
state. This state can be as simple as an integer that keeps a count of the
number of operations performed. In our case, we will use a map of strings to
values $V$,  modelling the use of variables in our program. The specific type 
of V will be described in a later section.

The State monad allows us to add the ability for tracking state to a pure
program. It is defined as \coq{Definition State (S A : Type) := S → (A * S). } 
The State monad wraps a value in a function that keeps track of an additional value of
type S. Looking at the types of State and return shows us how we ought to
implement the return function for State. 

\begin{minted}{coq}
Definition return_state {S A} : A → State A := 
    λ a : A, λ st : S, (a, st).
\end{minted}

The \coq{bindM } method for State passes the state variable along to the next
computation. Updates states are passed along and the current state is
accessible at each step of the computation operation.

\begin{listing}[H]
\begin{minted}{coq}
  Definition bind_state {A B} 
    (m : State S A) (f : A → State S B) : State S B :=
    λ st, match (m st) with
          | (x, st') => f x st'
          end.
\end{minted}
\caption{The implementation of bind for the State monad}
\label{lst:bind_state}
\end{listing}

Listing~\ref{lst:bind_state} shows us how the bind method is implemented. The
result of binding a State value to a function is a new function (as all values
of State need to be) in which the provided state variable is applied to the
State value. The result of this computation, including the new updated state,
is then passed to the continuation function $k$.

The State and Maybe monads show us how we would implement the desired
properties of our Toy language in a pure manner. But right now, we will have to
change between the two. We can either have the evaluator utilize the State
monad to keep track of state, or have it use the Maybe monad to allow
exceptions, but we cannot have a runtime in which we can both throw exceptions
as well as keep track of a global state. 

There is a way to combine the functionalities of monads via the use of monad
transformers. 

\subsection{Monad Transformers}~\label{sec:monad_transformers}
Monad transformers\cite{liang1995monad} are a way to add the side effects of a
monad to another monad. To facilitate this, we introduce another typeclass.

\begin{listing}
\begin{minted}{coq}
  Class MonadT (T : (Type → Type) → (Type → Type)) 
    `{∀ M, Monad M → Monad (T M)} : Type :=
  {
    liftT : ∀ {M} `{Monad M} {A}, 
      M A → T M A;
    lift_return : ∀  {M} `{Monad M} {A} (a : A), 
      liftT (returnM a) = returnM a;
    lift_bind : ∀ {M} `{Monad M} {A B} (m : M A) (f : A → M B),
      liftT (m >>= f) = liftT m >>= (f ∘ liftT);
  }.
\end{minted}
\end{listing}

The notation \coq{`{∀ M, Monad M → Monad (T M)} } indicates that whenever we define an
typeclass instance for a type T, we require that (T M), which should be of type
Type → Type, is also a monad instance. That means that all the returnM and
bindM methods, as well as the monad laws, apply to the transformed monad (T M).
In addition, we also have access to a new method liftT, which allows us to
utilize methods defined for the underlying monad by "lifting" them to the
transformed monad. 

We define two transformer monads that correspond to the monads defined above:
MaybeT and StateT. These extend a monad by allowing for failing computations
and the ability to retain a global state. 

\begin{listing}
\begin{minted}{coq}
Definition MaybeT M A: Type := M (Maybe A).
Definition StateT S M A : Type := S → M (A*S)%type.
\end{minted}
\caption{Definitions for the monad transformers}
\end{listing}

When providing instances for the Monad typeclass for these types, we require
the use of the bind and return methods of the wrapping monad $M$.
For example, in listing~\ref{lst:bind_maybeT}, we see that the implementation 
of  bind for \coq{MaybeT }
unwraps the monad M, exposing the underlying Maybe value. We perform a case
analyis on this value in a way that is similar to how we defined
\coq{bind_maybe },
\coq{None } values are propagated and values wrapped with \coq{Just } are 
threaded through chained bind calls.

\begin{listing}
\begin{minted}{coq}
  Definition bind_maybeT {A B} (x : MaybeT M A) 
    (f : A → MaybeT M B) : MaybeT M B :=
    bindM (M:=M) x (λ v : Maybe A,
      match v with
      | None => returnM None
      | Just a => f a
      end
    ).
\end{minted}
\caption{Implementation of $>>=$ for MaybeT}
\label{lst:bind_maybeT}
\end{listing}

Aside from State and Maybe, we also implemented the Identity monad. This monad,
like the identity function, adds no extra functionality. 
\begin{minted}{coq}
Inductive Identity (A : Type) : Type := 
    identity : A → Identity A.
\end{minted}

Its value lies in the
ability to use it where we would a monad in cases where we don't want to add
extra functionality. To reduce our code base, we implemented State as the
StateT transformer applied to the Identity monad. The resulting monad
simplifies to our prior definition of State, without us needing to prove
soundness of the new monad.


\subsection{MonadFail, MonadExcept and MonadState}
With the use of monad transformers and lifting we are able to build a so-called 
monad stack to encode any side effects we may want in a pure way. However, when
we write code that reasons about possible side effects, we do not wish the
remember to exact number of lifts required to get to the underlying monad that
encodes those side effects. 

For this usecase, we have ported MonadFail, MonadExcept and MonadState from
Haskell~\cite{gibbons2011just}. The easiest way to explain why we use these typeclasses is that 
the typeclasses Maybe and State were more concerned with
\textit{how} the side effects were implemented, whereas these typeclasses deal 
more with \textit{what} side effects a type can cause.

\begin{listing}
\begin{minted}{coq}
Class MonadFail M `{M_monad : Monad M} : Type := {
  fail : ∀ {A}, M A;
  fail_left: ∀ {A B} (m : A → M B), (@fail A) >>= m = fail;
}.
\end{minted}
\caption{Definition of the MonadFail typeclass}
\label{lst:monadfail}
\end{listing}

Listing~\ref{lst:monadfail} shows the definition for the MonadFail typeclass.
The definition tells us two things: all instances of MonadFail have a value
called fail, and when this value is used on the left-hand side of a bind, the
resulting value is also fail.

The implementation of this typeclass for the Maybe monad is simple. We just use
None as the fail value. The proof for the fail\_left lemma follows readily from
the definition of bind\_maybe. The same goes for MaybeT, in which case our fail
value is \mintinline{coq}{returnM None }.

However, things get slightly more interesting when looking at State and StateT.
The normal State monad is not an instance of MonadFail. This should not come as
a surprise, as the point of this monad was to add a read/write state and not
the possibility of failure. StateT, however, preserves the ability for failure
if the underlying monad is an instance of MonadFail.

\begin{listing}
\begin{minted}{coq}
Section fail_stateT.
  Context {M : Type → Type} `{M_fail : MonadFail M}.
  Context {S : Type}.

  Definition fail_stateT {A} : StateT S M A := lift_stateT fail.

  Lemma fail_stateT_left : ∀ (A B : Type) (s : A → StateT S M B),
    fail_stateT (A:=A) >>= s = fail_stateT.
  Proof.
    intros. unfold fail_stateT, lift_stateT. ext. 
    autorewrite with soundness. 
    unfold bindM; simpl; unfold bind_stateT. 
    autorewrite with soundness. reflexivity.
  Qed.

  Global Instance monad_fail_stateT : MonadFail (StateT S M) :=
  {
    fail := @fail_stateT;
    fail_left := fail_stateT_left;
  }.
End fail_stateT.
\end{minted}
\caption{The MonadFail instance of StateT}
\label{lst:monadfail_stateT}
\end{listing}

Listing~\ref{lst:monadfail_stateT} shows the usage of a lift method to change
the fail method of the underlying MonadFail to work for the transformed StateT
monad instead. The proof unfolds the methods defined in terms of StateT and
rewrites the goal based on the monadic laws for bind and the fail\_left lemma.

Now that we have described monads that can fail, it comes natural to think
about monads that can recover from failure. To describe this ability, we have
the MonadExcept typeclass.

\begin{listing}
\begin{minted}{coq}
Class MonadExcept M `{M_fail : MonadFail M} A := {
  catch : M A → M A → M A;
  catch_left : ∀ (x : M A), catch fail x = x;
  catch_right : ∀ (x : M A), catch x fail = x;
  catch_return : ∀ (x : M A) (a : A),
    catch (returnM a) x = returnM a;
}.
\end{minted}
\caption{The MonadExcept typeclass}
\label{lst:monadexcept}
\end{listing}

The MonadExcept typeclass is a subtype of the MonadFail typeclass; all
instances of MonadExcept also need to be instances of MonadFail. Recovering
from failure is meaningless without the ability to fail.

For all instances of MonadExcept, we define a catch function. This function
is a lot like try-catch functionality in languages such as Java. The function
should take two values of type M A. If the first is fail, it returns the
second provided value. If it is not, it returns the first provided value. This
functionality is encoded in the lemmas attached to the typeclass.

\begin{listing}
\begin{minted}{coq}
Class MonadState (S : Type) (M : Type → Type) `{M_monad : Monad M} :=
{
  get : M S;
  put : S → M unit;
}.
\end{minted}
\caption{The MonadState typeclass}
\label{lst:monadstate}
\end{listing}

In the same way that we use typeclasses to easily access the fail effects, we 
can use a typeclass to access the state that is carried by the (transformed)
monad. Any monad implementing the MonadState typeclass should provide access to
a get method that sets the current state as the 'return value' of the function,
and a put method that updates the carried state with the given value.

\begin{listing}
\begin{minted}{coq}
Section store_stateT.
  Context (M : Type → Type) `{M_monad : Monad M}.
  Context {S : Type} `{!Inhabited S}.

  Definition stateT_get := λ s : S, returnM (s, s).

  Definition stateT_put := λ s : S, λ _ : S, returnM (tt, s).

  Global Instance store_stateT : 
  MonadState S (StateT _ M) :=
  {
    get := stateT_get;
    put := stateT_put;
  }.
End store_stateT.
\end{minted}
\caption{The State instance of MonadState}
\label{lst:monadstate_state}
\end{listing}

Now that we've described the monads used in the project and the 
theories behind them, we turn to the implementation of the concrete
interpreter. In the next section, we start by defining the language that is to
be interpreted, and how we compose the monads to do so.

\section{The Concrete Interpreter}\label{sec:concrete}

\subsection{Language Syntax}
\label{sec:lang}
Programs consist of statements and expressions. These programs are evaluated by
interpreters. In this subsection, we shall describe the syntax of a toy
language.

\begin{listing}
\begin{minted}{Coq}
Inductive cvalue : Type :=
  | VNat : nat → cvalue
  | VBool : bool → cvalue.
\end{minted}
\end{listing}

Our toy language has two types of values. Natural numbers, represented by
\mintinline{coq}{VNat } and boolean values, represented by \mintinline{coq}{VBool }. 
When a \mintinline{coq}{cvalue }, short for concrete value is needed, any of
these two types can be used.

Expressions are operations on values that result in a new value. They are
implemented as an inductive type called \mintinline{coq}{expr }. 

\begin{listing}
\begin{minted}{coq}
Inductive expr : Type :=
  | EVal : cvalue → expr
  | EVar : string → expr
  | EPlus : expr → expr → expr
  | EMult : expr → expr → expr
  | EEq : expr → expr → expr
  | ELe : expr → expr → expr
  | ENot : expr → expr
  | EAnd : expr → expr → expr.
\end{minted}
\end{listing}

Expressions can exist of concrete values (`5', `true'), names of variables
saved in a store (see Section~\ref{sec:stores}) and operations on these values
(+, *, ==, $<$, negation and $\&\&$). 

\begin{listing}
\begin{minted}{coq}
Inductive com : Type :=
  | CSkip : com
  | CSeq : com → com → com
  | CAss : string → expr → com
  | CIf  : expr → com → com → com
  | CTryCatch : com → com → com
  | CThrow : com. 
\end{minted}
\end{listing}

Statements control the flow of the program. In this case, we have implemented a
skip statement that effectively does nothing, an assigment statement that
assigns the result of an expression to a variable, an if statement, a try-catch
statement and a throw statement that acts as an exception.

\subsubsection{Stores}\label{sec:stores}
When evaluating the assignment statement \mintinline{coq}{CAss } and the variable
expression \mintinline{coq}{EVar }, the interpreter should write to and read from a variable
storage. We call these stores. 

The concrete store is a map\footnote{The \textit{total\_map} comes from 
	Map.v from the public Software Foundations course.\cite{softwarefoundations}} 
from strings to cvalues. The store is implemented as a total map, which is a
map that returns a default value when a key is requested that is not present in
the map. Values can be added to the map via the \mintinline{coq}{t_update }
function.

We could also have used a partial map. Partial maps instead return an option,
the Coq equivalent of our Maybe, instead of the basic type.
Returning the default None value would be akin to throwing an exception.
% maybe explain why I didn't use a partial map?

\begin{listing}
\begin{minted}{coq}
Definition store := total_map cvalue.

Definition t_update {A:Type} (m : total_map A)
                    (x : string) (v : A) :=
  λ x', if beq_string x x' then v else m x'.

\end{minted}
\end{listing}

\subsubsection{Do notation}
The interpreters make excessive use of the bind function of the monads.
Because of this, we introduce a special notation for the function.

\begin{listing}
\begin{minted}{Coq}
Notation "x '<<' y ; z" := (bind y (λ x, z))
  (at level 20, y at level 100, 
   z at level 200, only parsing).
\end{minted}
\end{listing}

If we did not include this notation, making use of the Monad would quickly
become cumbersome. With it, we are able to write data pipelines in an
imperative style. To illustrate, the below code shows the two
different styles. As the length of the `imperative' program increases, the
functional notation grows more cumbersome and error prone due to the number of
parenthesis involved.

\begin{listing}
\begin{minted}{coq}
Definition do_notation :=
	v << (eval_expr e) ;
	b << (ensure_bool v) ;
	returnM (VBool (negb b)).

Definition nested_notation :=
	(eval_expr e) >>= (λ v,
		(ensure_bool v) >>= (λ b,
			returnM (VBool (negb b)))).
\end{minted}
\end{listing}

\subsubsection{The interpreter}
As shown in Section~\ref{sec:lang} the syntax of the language allows the two
types of values, booleans and natural numbers, to be used interchangably while
still have a valid syntax. However, most operations will be meaningless if used
on the wrong operators. For example, ``1 + true'' is valid syntax, but it is 
not a valid program.

To ensure that the correct types are used when evaluating operators,
the interpreter has an `ensure' function for each of the types. 

\begin{listing}
\begin{minted}{Coq}
Definition ensure_nat `{M_fail : MonadFail M} (v : cvalue) : M nat :=
  match v with
  | VNat x => returnM x
  | _ => fail
  end.
            
Definition ensure_bool `{M_fail : MonadFail M} (v : cvalue) : M bool :=
  match v with
  | VBool b => returnM x
  | _ => fail
  end.
\end{minted}
\end{listing}

Notice that both ensure functions are parametrized over a monad M that is
capable of failing. This allows us to resuse these functions with whatever
stack of monad transformers we desire, as long as one of those monad
transformers adds the ability to fail e.g., MaybeT is on the stack or Maybe is
the inner-most monad.

When the ensure function is called with a type other than the desired type, it
returns the fail value of its monad M. As a consequence of the
fail\_left lemma, this failure is propagated throughout the rest of the
program.

\begin{listing}[H]
\begin{minted}{Coq}
Fixpoint eval_expr (e : expr) : M cvalue :=
  match e with
  | EVal x => returnM x
  | EVar x => st << get ;
      returnM (st x)
  | EPlus e1 e2 => 
      v1 << (eval_expr e1) ;
      v2 << (eval_expr e2) ;
      n1 << (ensure_nat v1) ;
      n2 << (ensure_nat v2) ;
      returnM (VNat (n1 + n2))
  | EMult e1 e2 =>
      v1 << (eval_expr e1) ;
      v2 << (eval_expr e2) ;
      n1 << (ensure_nat v1) ;
      n2 << (ensure_nat v2) ;
      returnM (VNat (n1 * n2))
  | EEq e1 e2 =>
      v1 << (eval_expr e1) ;
      v2 << (eval_expr e2) ;
      n1 << (ensure_nat v1) ;
      n2 << (ensure_nat v2) ;
      returnM (VBool (Nat.eqb n1 n2))
  | ELe e1 e2 =>
      v1 << (eval_expr e1) ;
      v2 << (eval_expr e2) ;
      n1 << (ensure_nat v1) ;
      n2 << (ensure_nat v2) ;
      returnM (VBool (Nat.leb n1 n2))
  | ENot e =>
      v << (eval_expr e) ;
      b << (ensure_bool v) ;
      returnM (VBool (negb b))
  | EAnd e1 e2 =>
      v1 << (eval_expr e1) ;
      v2 << (eval_expr e2) ;
      b1 << (ensure_bool v1) ;
      b2 << (ensure_bool v2) ;
      returnM (VBool (andb b1 b2))
  end.
\end{minted}
\end{listing}

The concrete interpreter follows the same structure for each kind of operator.
The smaller expressions are evaluated first via recursive calls to the
evaluation function and the interpreter
ensures they are of the proper types. Then, the built-in operator corresponding
to the expression is called on those values.

\begin{listing}[H]
\begin{minted}{Coq}
Fixpoint ceval {M} `{MonadExcept M, MonadState M} (c : com) : M unit :=
  match c with
  | CSkip => returnM tt
  | c1 ;c; c2 => 
      (ceval c1) ;; (ceval c2)
  | x ::= a => 
      n << (eval_expr a) ;
      st << get ;
      put (t_update st x n)
  | CIf b c1 c2 => 
      v << (eval_expr b) ;
      b' << (ensure_bool v) ;
      if b' (ceval c1) (ceval c2)
  | try c1 catch c2 =>
   	  catch (ceval c1) (ceval c2)
  | CFail => fail
  end.
\end{minted}
\caption{The concrete interpreter for statements}
\label{lst:concrete_statements}
\end{listing}

The ceval function is the concrete interpreter of our language. It requires
that the monad M that is used is an instance of both MonadExcept and
MonadState. This gives us access to get, put, catch and fail, which we need for
variables and exceptions.

\section{Galois Connections}
In this section we will describe the notion of Galois
connections~\cite{cousot1992comparing}. 
Before we do
so, we will take a quick detour to preordered sets. We define type classes for
preordered sets and define monotonicity before moving on to define a type 
class for Galois connections.

\subsection{Preordered sets}
The first definition we shall implement is the notion of a preordered set. 
A preordered set is any set S on which we can define a preorder relation
$\sqsubseteq$ such that the preorder relation is reflexive and transitive. That
is, for all $a, a \sqsubseteq a$ (reflexivity) and for all $a$ $b$ $c$, if $a
\sqsubseteq b$ and $b \sqsubseteq c$, then $a \sqsubseteq c$ (transitivity).
We refer to such a combination of set S and relation as $(A, \sqsubseteq)$.

The definitions of reflexive and transitive relations are already included in
the standard library of Coq, so we can import those. This gives us the
following definition of the preorderd set as a Coq type class.

\begin{listing}
\begin{minted}{Coq}
Class PreorderedSet (X : Type) : Type :=
{
  preorder : X → X → Prop;
  preorder_refl: Reflexive preorder;
  preorder_trans: Transitive preorder;
}.
Infix "⊑" := preorder (at level 40).
\end{minted}
\end{listing}

In addition, we introduce the notation ⊑ to denote a preorder.

\subsubsection{Galois connections}
We require the definition of a preordered set in order to be able to define a
Galois connection.

Traditionally, Galois connections are defined on two partially ordered sets.
However, they can also be defined on preordered sets, and for our purposes that
works too. 
The difference between preordered sets and partially ordered sets is
that a partial order is antisymmetric in addition to reflexive and transitive.
We do not require the antisymmetric property, so we can loosen that restraint.

The definition of Galois connections that we have implemented is that of the
monotone Galois connection. Given two preordered sets $(A,\sqsubseteq)$ and
$(B,\sqsubseteq)$, a Galois connection between those two sets is defined as two
functions $\alpha : A \rightarrow B$ and $\gamma : B \rightarrow A$ such 
that $\alpha(a)
\sqsubseteq b$ iff $a \sqsubseteq \gamma(b)$.

\begin{minted}{Coq}
Class Galois (A A' : Type) `{PreorderedSet A'} : Type :=
{
  gamma : A' → A → Prop;
  gamma_monotone : monotone gamma;
}.
\end{minted}

Instancing the Coq type class definition of Galois connections between two
types $A$ and $B$ requires supplying those types, as well as a gamma function
$gamma : B \rightarrow A \rightarrow Prop$ that is monotone. 
A monotone function $f : A \rightarrow B$ is
a function between two preordered sets $A$ and $B$ such that if $a \sqsubseteq
a'$, then $f(a) \sqsubseteq f(a')$.

Note that the Coq definition does not require A to be a preordered set. This is
because we actuall consider Galois connections between $\mathcal{P}(A)$ and
$B$. For example, we will consider the relation between sets of natural numbers
e.g.\ $\{2, 4, 8\}$ and parities e.g.\ even.

Another difference between the Coq implementation and the mathematical
definition is the lack of corresponding \textit{alpha} function. This is
because we are unable to define this function, due to limitations in Coq.
Luckily, it turns out that the $\alpha$ function is not necessary to prove
soundness~\cite{jourdan2016verasco}.

It is difficult to grasp what a Galois connection means from the definition
alone, so we will provide a few examples in the next section, after
introducing the abstract types.

\subsubsection{Parities}
The first abstract type we define is \coq{Parity }.

\begin{listing}
\begin{minted}{Coq}
Inductive parity : Type :=
  | par_even : parity
  | par_odd : parity
  | par_top : parity.
\end{minted}
\end{listing}

The parity of a natural number is whether it is even or odd; e.g.\ the parity
of the number 2 is even, and the parity of the number 9 is odd. The top value
represents any natural number.

We can define a Galois connection between natural numbers and the parity type.
To do so, we must provide a gamma function and prove its monotonicity. Recall
that the signature is of the form $A' \rightarrow A \rightarrow Prop$. In this
case, we shall use \coq{parity } as $A'$ and \coq{nat } as $A$.

Any type of the form $B \rightarrow Prop$ can be seen as sets of $A'$. We define
a function \coq{gamma_par } as taking a parity as a parameter and returning
sets of natural numbers.

\begin{listing}
\begin{minted}{Coq}
Inductive gamma_par : parity → nat → Prop :=
  | gamma_par_even : ∀ n, Nat.Even n → gamma_par par_even n
  | gamma_par_odd  : ∀ n, Nat.Odd n → gamma_par par_odd n
  | gamma_par_top  : ∀ n, gamma_par par_top n.
\end{minted}
\end{listing}

In the provided code, the even and odd symbols are imported from the Coq
standard library. They are the sets of even and odd numbers respectively. Each
of the three possible values of parity is mapped to a set of natural numbers.

\begin{listing}
\begin{minted}{Coq}
Instance galois_parity_nat : Galois nat parity :=
{
  gamma := gamma_par;
  gamma_monotone := gamma_par_monotone;
}.
\end{minted}
\end{listing}

The above code shows how a Galois connection between sets of natural numbers 
and parities is instantiated. \coq{gamma_par_monotone } refers to the proof the
the \coq{gamma_par } function is monotone. This proof has been omitted for 
brevity.

\subsubsection{Intervals}
Parities are only one possible abstraction of natural numbers. Another
possibility would be to use intervals. In this section, we describe the
implementation of intervals using dependent records.

An interval of natural numbers is a valid abstraction of a set of natural
numbers if each of the natural numbers in the set falls within the interval.
For example, the the interval $[1,5]$ is an abstract approximation of the set
$\{2, 4, 5\}$. It is also a valid approximation of the set $\{1,5\}$. This
again illustrates the fact that the abstract approximation often lose 
precision.

The same operators than can be defined on natural numbers can be defined on
intervals. Addition, multiplication and comparisons can all be implemented.
Adding the intervals $[1,3]$ and $[4, 7]$ would result in the interval $[5,
10]$, for example. Whenever we define an interval, we also need to provide a
proof that the mininum end of the interval is less than the maximum end. This
is represented in the record by the \coq{min_max } field.

\begin{listing}
\begin{minted}{coq}
Record interval := Interval {
  min: nat;
  max : nat;
  min_max : min <= max;
}.

Inductive gamma_interval : interval → nat → Prop :=
  | gamma_interval_cons : ∀ i n, 
      preorder (min i) n → preorder n (max i) →
      gamma_interval i n.
\end{minted}
\end{listing}

\subsubsection{Abstract Booleans}
The abstract booleans are only slightly different from their concrete
counterpart. We supplement the normal boolean values (true and false) with
a value for top. As with the parities, the abstract value ab\_top
represent both concrete values.

\begin{minted}{Coq}
Inductive abstr_bool : Type :=
  | ab_true   : abstr_bool
  | ab_false  : abstr_bool
  | ab_top    : abstr_bool.
\end{minted}

\begin{minted}{Coq}
Definition gamma_bool (ab: abstr_bool) (b : bool) : Prop :=
  match ab with
  | ab_true   => Is_true b
  | ab_false  => ~Is_true b
  | ab_top    => True
  end.
\end{minted}

The gamma function for booleans is straightforward due to the limited
number of concrete values. As with \coq{gamma_par }, the top 
value is mapped to True.

\section{The Abstract Interpreter}
As with the concrete interpeter, the abstract interpreter has the
\coq{ensure_* } functions for the abstract types. 
They are very similar to the ensure functions above and are omitted for brevity. 

We again define the interpreter in a monad-agnostic way. We only require the
used monad to have the same capabilities as the one in the concrete
interpreter, namely failing and state.

The abstract state differs from the concrete state in what values, and with
those, what type of store is
used. The abstract store is almost the same is the concrete store, but returns
abstract values instead of concrete values. When concrete values are inserted
in the store, they are first converted into their abstract counterpart via the
extract function.

\begin{listing}[H]
\begin{minted}{Coq}
Inductive avalue : Type :=
  | VParity : parity -> avalue
  | VAbstrBool : abstr_bool -> avalue
  | VInterval : interval -> avalue
  | VTop : avalue
  | VBottom : avalue.

Definition extract (v : cvalue) : avalue :=
  match v with
  | VNat x => VParity (extract_par x)
  | VBool x => VAbstrBool (extract_bool x)
  end.
\end{minted}
\end{listing}

\begin{listing}[H]
\begin{minted}{Coq}
Fixpoint eval_expr_abstract {M} `{MonadExcept M, MonadState M} 
    (e : expr) : M avalue :=
  match e with
  | EVal x => returnM (extract x)
  | EVar x => st << get ;
      returnM (st x)
  | EPlus e1 e2 => 
      v1 << (eval_expr_abstract e1) ;
      v2 << (eval_expr_abstract e2) ;
      n1 << (ensure_par v1) ;
      n2 << (ensure_par v2) ;
      returnM (VParity (parity_plus n1 n2))
  | EMult e1 e2 =>
      v1 << (eval_expr_abstract e1) ;
      v2 << (eval_expr_abstract e2) ;
      n1 << (ensure_par v1) ;
      n2 << (ensure_par v2) ;
      returnM (VParity (parity_mult n1 n2))
  | EEq e1 e2 =>
      v1 << (eval_expr_abstract e1) ;
      v2 << (eval_expr_abstract e2) ;
      n1 << (ensure_par v1) ;
      n2 << (ensure_par v2) ;
      returnM (VAbstrBool (parity_eq n1 n2))
  | ELe e1 e2 =>
      v1 << (eval_expr_abstract e1) ;
      v2 << (eval_expr_abstract e2) ;
      n1 << (ensure_par v1) ;
      n2 << (ensure_par v2) ;
      returnM (VAbstrBool (ab_top))
  | ENot e =>
      v << (eval_expr_abstract e) ;
      b << (ensure_abool v) ;
      returnM (VAbstrBool (neg_ab b))
  | EAnd e1 e2 =>
      v1 << (eval_expr_abstract e1) ;
      v2 << (eval_expr_abstract e2) ;
      b1 << (ensure_abool v1) ;
      b2 << (ensure_abool v2) ;
      returnM (VAbstrBool (and_ab b1 b2))
  end.
\end{minted}
\end{listing}

The abstract interpreter for expressions looks much the same as the concrete
version. The differences are in which type of ensure function is called and in
that the operations on the types are now the abstract versions. For example,
where the concrete interpreter called the standard plus operator for natural
numbers, the abstract interpreter calls the parity plus function.

\subsubsection{The AbstractMaybe monad}
Thus far, we have seen the fail method of Maybe used to model crashed programs
due to type mismatches, for exampling when adding booleans. In our language, we
also wish to model exceptions. Consider the following Java snippet.

\begin{minted}{java}
if (x == 0) {
    throw new Exception();
else {
    x = 3;
}
\end{minted}

We could try to model such a program with just the fail value of Maybe. 
This proves insufficient when this program is interpreted in an abstract way, 
because an abstract interpreter might be uncertain whether $x$ is equal to 
$0$ or not and has to reflect this in the returned value.

We introduce the monad AbstractMaybe~\cite{keidel2018compositional} 
to capture this side effect.

\begin{minted}{coq}
Inductive AbstractMaybe (A : Type) : Type :=
| NothingA : AbstractMaybe A
| JustA : A → AbstractMaybe A
| JustOrNothingA : A → AbstractMaybe A.
\end{minted}

In addition to constructors modeling successful and failed operations, this
type has a constructor that models uncertainty as to whether the operation has
succeeded.

As with all abstract types, we need an ordering and a gamma connection. We
define a lattice with \coq{JustOrNothingA } as the top element. \coq{NothingA } and
\coq{JustA } correspond to \coq{Nothing } and \coq{Just }, which we see reflected
in the gamma function in Listing \ref{lst:gamma_maybeA}.

\begin{listing}
\begin{minted}{coq}
Inductive maybea_le : AbstractMaybe A → AbstractMaybe A → Prop :=
| maybea_le_nothing : maybea_le NothingA NothingA
| maybea_le_nothing_justornothing : ∀ y, 
    maybea_le NothingA (JustOrNothingA y)
| maybea_le_just : ∀ x y, 
    preorder x y → 
    maybea_le (JustA x) (JustA y)
| maybea_le_justornothing_r : ∀ x y, 
    preorder x y →
    maybea_le (JustA x) (JustOrNothingA y)
| maybea_le_justornothing : ∀ x y, 
    preorder x y →
    maybea_le (JustOrNothingA x) (JustOrNothingA y).
\end{minted}
\end{listing}

\begin{listing}
\begin{minted}{coq}
Inductive gamma_maybeA : AbstractMaybe A' → Maybe A → Prop :=
| gamma_nothingA : gamma_maybeA NothingA Nothing
| gamma_justornothingA_nothing : ∀ a, 
    gamma_maybeA (JustOrNothingA a) Nothing
| gamma_justA_just : ∀ a' a, 
    gamma a' a → 
    gamma_maybeA (JustA a') (Just a)
| gamma_justornothing_just : ∀ a' a, 
    gamma a' a →
    gamma_maybeA (JustOrNothingA a') (Just a).
\end{minted}
\caption{Gamma function for AbstractMaybe}
\label{lst:gamma_maybeA}
\end{listing}

As with Maybe, we have monad transformer that adds this functionality to a
monad. We call this transformer MaybeAT, and we define it as \\
\coq{Definition MaybeAT M A := M (AbstractMaybe A). }

\section{Extracting the Shared Interpreter}\label{sec:shared_interpreter}
As observed in the previous section, the abstract and concrete interpreter
share many similarities. This leads us to the question of whether we can
decompose the interpreters along the shared structure in a way that eases the
proof burden. In this section, we look at how we have extracted the shared
interpreter and how this shared structure can be instantiated to create
abstract and concrete interpreters like those defined earlier.

\subsection{IsBool and IsNat}
The shared interpreter needs to have a uniform way of handling values, as it
can be instantiated with either abstract or concrete values. For every type of
concrete value we will require a corresponding interface. In our case, this
means that we will require an interface for boolean types and an interface for
numerical types.

\begin{minted}{Coq}
Class IsBool (M : Type → Type)
  (valType boolType : Type) : Type :=
{
  ensure_bool  : valType → M boolType;
  build_bool   : boolType → M valType;
  extract_bool : bool → M boolType;
  and_op       : boolType → boolType → M boolType;
  neg_op       : boolType → M boolType;
  if_op        : boolType → M unit → M unit → M unit;
}.
\end{minted}

The IsBool typeclass is the interface for the boolean types. The interface
exposes all the operators that are possible on booleans. We've defined the and
operator and the negation operator. We also include the if operator in this
interface, as the behaviour of if will change depending on the boolean type. 

In addition, there are also the ensure, build and extract functions. The ensure
function checks whether the supplied value is actually of the type the
typeclass is instantiated for. If not, the program will crash. This ensure
function is called before the aforementioned operators, as they are not defined
for natural numbers. The build function wraps a boolean type in the value type
so that it can be passed along into other functions. The extract function can
turn a concrete value into a boolType. In the concrete implementation
of the IsBool typeclass, this will be the identity function.

\begin{minted}{Coq}
Definition ensure_abool {M} `{MonadFail M} 
    (v : avalue) : M abstr_bool :=
  match v with
  | VAbstrBool b => returnM b
  | _ => fail
  end.

Definition eval_if_abstract {M} `{MonadFail M} 
    {A} `{Joinable A} 
    (b : abstr_bool) (st1 st2 : M A) : M A :=
  match b with
  | ab_true   => st1
  | ab_false  => st2
  | ab_top    => join_op st1 st2
  end.

Definition extract_ab (b : bool) : abstr_bool := 
  match b with
  | true => ab_true
  | false => ab_false
  end.

Instance abstract_boolean_type {M} `{MonadFail M} : 
  IsBool M avalue abstr_bool :=
{
  ensure_bool := ensure_abool;
  extract_bool := extract_abM;
  build_bool := build_abool;
  and_op := and_abM;
  neg_op := neg_abM;
  if_op := eval_if_abstract;
}.
\end{minted}

The above listing shows the abstract implementation of the IsBool typeclass.
The abstract if evaluation takes two monadic values and returns one based on the
given boolean value. In the case of the Top boolean value, it returns a join of
the two states, as the abstract interpreter will be unsure of what path to
take. The listing also shows how the extract function takes a concrete value
and turns it into the correct abstraction.

\begin{minted}{Coq}
Class IsNat (M : Type → Type)
  (valType boolType natType : Type) : Type :=
{
  ensure_nat  : valType → M natType;
  build_nat   : natType → M valType;
  extract_nat : nat → M natType;
  plus_op     : natType → natType → M natType;
  mult_op     : natType → natType → M natType;
  eq_op       : natType → natType → M boolType;
  le_op       : natType → natType → M boolType;
}.
\end{minted}

The typeclass for numerical types looks much the same. It has the same ensure,
build and extract functions, as well as the operators for numerical types;
addition multiplication, equality and less-than.

Using the above interfaces, we can define the shared interpreter.
\begin{minted}{Coq}
Definition extract_build_val 
    {M : Type → Type} 
    {valType boolType natType : Type}
    `{M_monad : Monad M, 
      nat_inst : IsNat M valType boolType natType, 
      bool_inst : IsBool M valType boolType}
    (v : cvalue) : M valType :=
  match v with
  | VNat n => n' <- extract_nat n; build_nat n'
  | VBool b => b' <- extract_bool b; build_bool b'
  end.

Fixpoint shared_eval_expr 
    {M : Type → Type} {valType boolType natType : Type}
    `{M_monad : Monad M, 
      store_inst : MonadState (total_map valType) M,
      nat_inst  : IsNat M valType boolType natType, 
      bool_inst : IsBool M valType boolType}
    (e : expr) : M valType :=
  match e with
  | EVal v =>
      extract_build_val v
  | EVar x =>
      s <- get;
      returnM (s x)
  | EPlus e1 e2 => 
      v1 <- shared_eval_expr e1 ;
      v2 <- shared_eval_expr e2 ;
      n1 <- ensure_nat v1 ;
      n2 <- ensure_nat v2 ;
      n <- plus_op n1 n2 ;
      build_nat n
  | EMult e1 e2 => 
      v1 <- shared_eval_expr e1 ;
      v2 <- shared_eval_expr e2 ;
      n1 <- ensure_nat v1 ;
      n2 <- ensure_nat v2 ;
      n <- mult_op n1 n2 ;
      build_nat n
  | EEq e1 e2 =>
      v1 <- shared_eval_expr e1 ;
      v2 <- shared_eval_expr e2 ;
      n1 <- ensure_nat v1 ;
      n2 <- ensure_nat v2 ;
      b <- eq_op n1 n2 ;
      build_bool b
  | ELe e1 e2 =>
      v1 <- shared_eval_expr e1 ;
      v2 <- shared_eval_expr e2 ;
      n1 <- ensure_nat v1 ;
      n2 <- ensure_nat v2 ;
      b <- le_op n1 n2;
      build_bool b
  | ENot e1 =>
      v1 <- shared_eval_expr e1 ;
      b1 <- ensure_bool v1 ;
      b <- neg_op b1;
      build_bool b
  | EAnd e1 e2 =>
      v1 <- shared_eval_expr e1 ;
      v2 <- shared_eval_expr e2 ;
      b1 <- ensure_bool v1 ;
      b2 <- ensure_bool v2 ;
      b <- and_op b1 b2 ;
      build_bool b
  end.
  
Fixpoint shared_ceval 
  {M : Type → Type} {valType natType boolType : Type}
  `{M_fail : MonadFail M, 
    store : MonadState (total_map valType)  M, 
    M_except : ∀ A, MonadExcept M A, 
    nat_inst : IsNat M valType boolType natType, 
    bool_inst : IsBool M valType boolType}
  (c : com) : M unit :=
  match c with
  | CSkip => returnM tt
  | c1 ;c; c2 =>
      (shared_ceval c1) ;; (shared_ceval c2)
  | x ::= a => 
      v <- shared_eval_expr a ;
      s <- get ;
      put (t_update s x v)
  | CIf b c1 c2 => 
      v <- shared_eval_expr b ;
      b' <- ensure_bool v ;
      if_op b' (shared_ceval c1) (shared_ceval c2)
  | TRY c1 CATCH c2 => 
      catch (shared_ceval c1) (shared_ceval c2)
  | CFail => fail
  end.
\end{minted}

The required instances are added as implicited contraints to the definitions of
the shared interpreter. By doing this, we can get the type engine of Coq to
infer the required instances for us. This greatly simplifies how we can now
define the abstract and concrete interpreters. We only need to supply the
desired monad and the desired abstraction.

\begin{minted}{Coq}
Definition ConcreteState := MaybeT (StateT store Maybe).

Definition AbstractState := 
  MaybeAT (StateT abstract_store Maybe).

Definition conrete_interpreter (c : com) : ConcreteState Abstractstate :=
  shared_ceval c.

Definition abstract_interpreter (c : com) : AbstractState unit :=
  shared_ceval (nat_inst:=isnat_parity _) c.
\end{minted}

We only have to define which State monad we want the interpreter to use.
Because the State type uses concrete types, it automatically infers that we
will also require the concrete instances of the Except, Store, IsBool and IsNat
typeclasses. In the next section, we shall discuss how defining the abstract
and concrete interpreters as implementations of the shared interpreter aids in
proving the soundness of the abstract interpreter.

\section{Soundness}\label{sec:soundness}
The main focus of this thesis is the soundness of the abstract interpreter. In
this section, we will define what it means for an abstract function to be sound
with regards to a concrete function, and show how we prove the abstract 
interpreter is sound with regards to the concrete interpreter. 

Our definition of sound is analogue to our definition of gamma: a abstract 
function is sound if its output approximates the output of a concrete function,
provided the inputs of the abstract function approximated the inputs of the
concrete function.

For example, \textbf{if} we have two functions $f : A \rightarrow B$ and $f' 
: A' \rightarrow B'$, where there are two Galois connections 
between $A$ and $A'$, and $B$ and $B'$ respectively, \textbf{then} when 
there is a gamma relation between the input values, there will be a gamma
relation between the output values.

This is a bit of an obtuse definition, so we will provide some examples. Let us
look at the soundness of the parity plus function. We will show what it
means for that function to be sound with regards to standard addition of
natural numbers.

\begin{minted}{Coq}
Definition parity_plus (p q : parity) : parity :=
  match p with 
  | par_top => par_top
  | par_even => q
  | par_odd => match q with
               | par_top => par_top
               | par_even => par_odd
               | par_odd => par_even
               end
  end.
\end{minted}

So in more concrete terms, the function \coq{parity_plus } is sound with 
regards to \coq{plus }
if when, if the inputs are related, the output is also related. In Coq, this 
notion of relatedness is written as follows

\begin{minted}{Coq}
Lemma parity_plus_sound : ∀ p1 p2 n1 n2, 
    gamma p1 n1 → gamma p2 n2 → 
    gamma (parity_plus p1 p2) (plus n1 n2).
\end{minted}

If \coq{p1 } is an abstract representation of \coq{n1 }, and \coq{p2 } is an 
abstract representation of \coq{n2 }, then \coq{parity_plus p1 p2 } should be an 
abstract representation of \coq{plus n1 n2 }. 

Due to the automation capabilities of Coq, the actual proof for the soundness
of the \coq{parity_plus } function is very short.

\begin{minted}{Coq}
Proof. 
  autounfold with soundness. repeat constructor. intros.
  destruct p1, p2; eauto with soundness.
Qed.
\end{minted}

The proof is written using case analysis. It considers all possible
constructors of the parities and simplies the result of the \coq{parity_plus }
function. Then it uses the lemmas from the standard libraries of adding 
combinations of even and odd numbers to solve the subgoals.

We have similar proofs for each of the operations on values. We will not list
all those proofs here, as they are all short and of similar structure. Examine
all possible input values; resolve the functions and ascertain the preservation
of the gamma relation in those cases where the hypotheses hold.

More interesting are the soundness proofs for the interpreters. Because the
abstract and concrete interpreters both consist of the same structure, the
shared interpreter, the interpreters can be decomposed along the same lines.

As discussed in Section~\ref{sec:monads}, we can decompose the program along
the lines of the bind methods. If we can proof that the bind methods of our
chosen monads are sound and that the functions called by the bind methods are
sound, than the entire interpreter is sound. 

By repeating the application of the soundness lemma of bindM, 
we can turn a goal concerning a series of binds into a series of subgoals, each
concerning only a pair of functions. These pairs will correspond to each of the
functions we've already proven the soundness of, such as \coq{parity_plus }, or
methods from the MonadExcept and MonadState typeclasses.

\begin{minted}{Coq}
Theorem eval_expr_sound : ∀ a,
  gamma (eval_expr_abstract a) (eval_expr a).
Proof.
  intros. unfold eval_expr_abstract, eval_expr. induction a; 
  repeat solve_binds; auto with soundness. 
Qed.

Theorem sound_interpreter:
  ∀ c, gamma (ceval_abstract c) (ceval c).
Proof.
  intros. unfold ceval_abstract, ceval. 
  induction c; simpl; repeat solve_binds; auto with soundness.
Qed.
\end{minted}

\subsection{Sample Programs}
Now that we have a proof of the soundness of the abstract interpreter for every
statement in the language, we will take a look at three concrete examples of a
program written in the language. 

\begin{minted}{Coq}
Definition program1 := 
  IF2 (ELe (EVal (VNat 5)) (EVal (VNat 4))) 
  THEN (CAss "x" (EVal (VBool true))) 
  ELSE (CAss "x" (EVal (VNat 9))).

Definition program2 :=
  CAss "x" (EVal (VNat 20)) ;c;
  IF2 (EEq (EVar "x") (EVal (VNat 10)))
  THEN CFail
  ELSE (CAss "x" (EVal (VNat 20))).

Definition program3 :=
  CAss "x" 
  	(EPlus (EVal (VNat 10)) (EVal ((VBool true)))).
\end{minted}

In more conventional notation, these programs correspond to

\begin{lstlisting}
IF 5 < 4 THEN x := true ELSE x:= 9
\end{lstlisting}

\begin{lstlisting}
x := 20; IF x == 10 THEN fail ELSE x:= 20
\end{lstlisting}

\begin{lstlisting}
x := (10 + true)
\end{lstlisting}

We will discuss how the two interpreters work through these programs. When the
concrete interpreter evaluates the first program, it is able to tell that 5 is
not less than 4. As such, it evaluates the first branch of the if statement and
ignores the second. As such, it will end up with a store that contains
\textit{true} as the value of $x$.

In contrast, the abstract interpreter, when using parities, extracts the 
abstract values for 5 and 4
and will end up with an if statement that compares the set of odd numbers with
the set of even numbers. It is unable to determine which of these is smaller
than the other so it evaluates to the top value for the abstract booleans. In
this case, it joins the stores of the two branches and this results in a store
with the abstract top value for $x$. The concrete value of \textit{true} is
sound with regards to this top value, and so the abstract interpreter is sound
for the first program.

In the case of the second program, the concrete interpreter will opt for the
else branch and return a store where x holds the value of 20. The abstract
interpreter again cannot determine whether the values are equal and results in
the top abstract boolean value. It returns a state that is a join between the
failed state and a result where x is 20, using the ExceptionOrReturn
constructor. This value is a valid approximation of the concrete result, so the
interpreter is again sound.

In the third program, both the abstract and concrete interpreter exhibit the
same behaviour. Because adding a boolean to an integer is illegal, both
interpreters crash on that expression. Any concrete state is approximated by
the crashed abstract state, including a crashed concrete state, so the
interpreter is sound when analyzing this program.

Of course, these examples have been simplified for clarity. A more advanced
implementation would be able to combine information from multiple abstractions,
such as intervals and parities, to correctly infer the path. 

