\chapter{Automation}
Coq provides the writers of proofs with many ways to automate the development
of proofs. In this chapter, we outline the ways in which we leveraged these
methods to simplify the work required for our proofs. Our work utilized the
automatic unfolding and rewriting of terms, the automatic applying of lemmas
using the hint databases and the ability to write custom tactics to shorten 
proofs using the automation databases.

\section{autounfold and autorewrite}

\begin{minted}{coq}
Definition parity_plus (p q : parity) : parity :=
    match p with
    | par_even => q
    | par_odd => match q with
                 | par_odd => par_even
                 | par_even => par_odd
                 end
    end.
Hint Unfold parity_plus : soundness.
\end{minted}

The automation tactics discussed in the next section, auto and
eauto, do not automatically perform case analysis.
proof for \coq{parity_plus_pareven }. To be able to automate this we would need
to recognize instances in which we need to perform a case analysis. For finding
such instances automatically we can use the autounfold tactic.

Autounfold uses a hint database like the autorewrite database. By adding
definition to the database using \coq{Hint Unfold. } we can instruct Coq to
automatically unfold that definition when using the autounfold tactic. Wherever
\coq{parity_plus } appeared in the proof, it would then be replaced by the
unfolded definition containing the match functions. In next section,
we show how the occurences of match in the goal aid in automating the proof.

When defining abstraction domains and instance of the monad typeclass, we can
often define lemmas regarding the equivalence of two values of a certain type.
For example, after defining the \coq{parity } type and the plus operator
for that type, we were able to define the lemma \coq{parity_plus_pareven }.

\begin{minted}{coq}
Lemma parity_plus_pareven : forall (p : parity),
    parity_plus par_even p = p.
Proof. 
    destruct p; reflexivity.
Qed.
Hint Rewrite parity_plus_pareven : soundness.
\end{minted}

These lemmas state that when adding two parities, if the first parity is even,
the result of the entire operation will be equal to the second parameter. In
other words, adding \coq{par_even } is idempotent. The destruct tactics
performs a case analysis on the parameter p and generates a subgoal for each
possible value it can take, in this case \coq{par_even } and \coq{par_odd }.
The ; links two tactics together, the latter tactic is performed on all
subgoals generated by the first. In both cases, the equality of
\coq{parity_plus par_even p } and \coq{p } follows from the definition of
\coq{parity_plus } so we can end the proof with the reflexivity tactic, which
solves goals of the form \coq{_ = _ } when both sides are equal.

The command \coq{Hint Rewrite. } adds the lemma to the rewrite database
soundness. Whenever we add in a later proof use this rewrite database via
\coq{autorewrite using soundness. }, Coq searches the hint database for any
applicable lemmas. By populating the rewrite database with lemmas that simplify
terms, such as \coq{parity_plus_even } we can often vastly simplify proofs.
Because autorewrite keeps going until no lemma is applicable, it can rewrite
complicated proofs into forms via rules that are not immediately obivous to
human readers.

This is especially apparent when adding the monad rules to the rewrite
database. Recall from Section~\ref{sec:monads} that the monad laws are a
follows.
\begin{minted}{coq}
Class Monad (M : Type → Type) : Type := {
  bind_id_left : ∀ {A B} (f : A → M B) (a : A), 
    bindM (returnM a) f = f a;
  bind_id_right : ∀ {A} (m : M A),
    bindM m returnM = m;
  bind_assoc : ∀ {A B C} (m : M A) (f : A → M B) (g : B → M C),
    bindM (bindM m f) g = bindM m (λ a, bindM (f a) g);
}.
\end{minted}

Repeated application of these lemmas rewrite computations involving monads into
a canonical form. Autorewrite can also take in any other laws regarding the
monad typeclasses we defined, such as those from MonadFail and MonadExcept.
When adding lemmas to the rewrite database, we must take care that we do not
add lemmas that would result in circular rewrites. If we do so, autorewrite
will keep thinking it is making progress and never terminate.

By combining the autorewrite and autounfold tactics, we can take a proof goal
and turn it into a canonical form. While the unfolding of definition often
makes the proof unwieldy for human readers by virtue of the length of the goal,
it eases the proof burden for the automation tactics as described in the next
section.

\section{Custom tactics and (e)auto}
Coq allows us to define our own custom tactics using the Ltac command. Using
such a custom tactic, we can take the unfolded goal generated by a combination 
of autorewrite and autounfold and turn it into a series of subgoals.

\begin{minted}{coq}
Ltac unmatch x :=
  match x with
  | context [match ?y with _ => _ end] => unmatch y
  | _ => destruct x eqn:?
  end.

Ltac destr :=
  match goal with
  | [ |- context [match ?x with _ => _ end]] => unmatch x
  | H : match ?x with _ => _ end |- _ => unmatch x
  | [ |- context [let (_, _) := ?x in _]] => destruct x eqn:?
  | H : (_ , _) = (_, _) |- _ => inv H
  | |- _ /\ _ => split
  | H : _ /\ _ |- _ => destruct H
  end.
\end{minted}

We use to custom tactics to achieve this. The first is the unmatch tactic. The
tactic takes a single parameter, which is supposed the name of a hypothesis in
the context. If the provided hypothesis is of the form \coq{match ?x with _ =>
_ end) }, we recursively call unmatch on the term on which case analysis is
performed. If it is of any other form, we simply destruct the provided term. 

The unmatch tactic allows us to recursively perform case analysis on match
statements in the context. It is called by the destr tactic, which is the
tactic that we will later include in the automation database.

The destr tactics performs a lot of checks to find instances in which we need
to perform case analysis. The first is to check if the goal contains match
statements, in which case the unmatch tactic is used. In the second case, we
resolve let-bindings in the goal. If the context contains a hypothesis
regarding the equivalence of the pairs, we call the custom inv tactic on that
hypothesis. This tactic is a wrapper around the built-in inversion tactic that
performs some cleanup. The result is two equality hypotheses for the individual
elements of the pair. Because the auto tactics from Coq also don't destruct the
logical AND operator, we add a case for those.  

The two main automation tactics provided by Coq are auto and eauto. The
difference between the two is that eauto may leave existential variables in the
goal, whereas auto will simply fail in those cases. Both tactics search a hint
database for lemmas that are applicable to the current goal. If such a lemma is
found, it is applied and the hint database is searched again for an applicable
lemma. It continues this until either the goal is finished or a preconfigured
depth is reached.

We can add hints to a hint database used by (e)auto using the \coq{Hint
Resolve. } and \coq{Hint Extern. } commands. \coq{Hint Resolve. } adds lemmas
that are applied to the goal if they match the conclusion of the lemma. 

\begin{minted}{coq}
Lemma parity_plus_sound : forall (p q : parity) (n m : nat),
    gamma p n -> gamma q m -> 
    gamma (parity_plus p q) (plus n m).
Proof. (* proof omitted *) Qed.
Hint Resolve parity_plus_sound.
\end{minted}

In the above example, auto would apply \coq{parity_plus_sound } if the goal is of the 
form \coq{gamma (parity_plus p q) (plus n m). }. It would then add two new
subgoals \coq{gamma p n} and \coq{gamma q m} and attempt to solve those. Adding
soundness lemmas for all monad operations and operations on the abstract
domains will allow us to proof the soundness of an abstract interpreter via the
auto tactics.

\coq{Hint Extern } is a more powerful way to add hints to the database. It
takes a pattern for the goal to have before executing the hint, and allows us
to perform any tactics we want when this pattern holds. Via this command we can
add the custom tactics defined above to the hint database, upgrading auto to
solve proofs requiring case analysis in addition to those merely requiring the
application of lemmas.
