\chapter{Challenges}

In this chapter, we describe some of the challenges we faced in implementing
the decomposition of the intepreters and proving their soundness. Specifically,
we cover the bind method of the optionAT monad.

\section{optionAT}~\label{sec:challenges-optionat}

The optionA monad is the abstract analogue of the option monad, a monad
designed to add the possibility of failure to a program. Aside from
constructors \coq{NoneA } and \coq{SomeA }, which correspond to \coq{None } and
\coq{Some }, the optionA monad also has a \coq{SomeOrNoneA } constructor.
We use this constructor in the cases where the interpreter cannot ascertain
whether the program has encountered an error or not. The optionAT monad is the
monad transformer that adds the capabilities of optionA to another monad.

In our work, we use the optionA monad to model exceptions, as opposed to
program crashes. It is possible to write a valid program in which in an
IF-statement only one of the branches raises an exception. If the abstract
interpreter cannot tell which path would be taken, the results of both branches
are joined into the \coq{SomeOrNoneA } value.

The challenge posed by the optionAT monad comes from its bind method. Our
first implementation of \coq{bind_optionAT } is given below.

\begin{listing}[H]
\begin{minted}{coq}
  Definition bind_optionAT {A B} 
    (Mma : optionAT M A)
    (f : A -> optionAT M B) : optionAT M B :=
  bindM (M:=M) Mma (λ ma,
    match ma with
    | NoneA => returnM NoneA
    | SomeA a => f a
    | SomeOrNoneA a => (
        bindM (M:=M) (f a) (λ mfa,
                       match mfa with
                       | NoneA => returnM NoneA
                       | SomeA b => returnM (SomeOrNoneA b)
                       | SomeOrNoneA b => returnM (SomeOrNoneA b)
                       end))
    end).
\end{minted}
\caption{First attempt at bind\_optionAT}
\label{lst:bind_optionAT}
\end{listing}

At a first glance, this implementation appears correct. Exceptions are properly
propagated throughout the binds, because whenever \coq{NoneA } is found the total
result will also be \coq{NoneA }. In cases of uncertainty, the value is properly
wrapped in the uncertain \coq{SomeOrNoneA } constructor. Additionally, this bind
method satisfies all the requirements imposed on it via the monad laws.

However, when we attempt to prove the soundness of the function we run into a
problem. Because \coq{bind_optionAT } is a method of a monad transformer, the
value of \coq{f a } is a transformed monad. That means that by evaluating it as
we do in the \coq{SomeOrNoneA } case, we also run the side effects of the
encapsulating monad. 

These are the side effects from the case where the first computation did not 
fail. However, to be sound, the \coq{SomeOrNoneA } case also needs to consider
the possibility that the computation did fail. This is exactly where the
soundness proof begins to break down if we use the above definition. We end up
with the unprovable and incorrect goal of 

\begin{minted}{coq}
γ 
    (f' a >>= λ mfa,
       | SomeA b | SomeOrNoneA b => returnM (SomeOrNoneA b) 
       | NoneA => returnM NoneA) 
    (returnM None).
\end{minted}

We require some way to broaden the encapsulated monad so that the side-effects of
both branches are included. We will detail a few of our attempts in the
following sections.

\subsubsection{Attempt 1: Joinable}~\label{sec:optionat_join}
An important part of the definition of the Galois connections was that the
abstract values are part of a lattice. The abstract values consist of a set
equipped with a preorder. Because we have a lattice for all abstract values, we
can define the least upper bound for two abstract values.

We define a Joinable typeclass, with the requirement that instances of the
typeclass are also instances of the PreorderedSet typeclass. Instances of
Joinable have a \coq{join_op } method, which takes two values and returns their
least upper bound. We use this typeclass to merge the values of two branches.
This makes it seem like Joinable is the way to solve the challenge of optionAT
as well.

\begin{listing}
\begin{minted}{coq}
Class Joinable (T : Type) {PT : PreorderedSet T} : Type :=
{
  join_op : T -> T -> T;
  join_idem : ∀ x, join_op x x = x;
  join_upper_bound_left: ∀ t t', preorder t (join_op t t');
  join_upper_bound_right: ∀ t t', preorder t' (join_op t t');
  join_assoc : ∀ x y z : T, 
    join_op x (join_op y z) = join_op (join_op x y) z;
  join_comm : ∀ x y, join_op x y = join_op y x;
}.
Infix "⊔" := join_op (at level 40).
\end{minted}
\caption{The Joinable typeclass}
\label{lst:joinable_typeclass}
\end{listing}

Included in the Joinable typeclass are two lemmas, 
\coq{join_upper_bound_left } and \coq{join_upper_bound_right }. 
These make sure that the result of \coq{join_op } is a valid approximation
of all the concrete values approximated by either of the two input values. 
The interval [1,3] approximates the number 1, and the interval [2,5]
approximates 4. The join of those intervals is [1,5], which approximates both 1
and 4. Because we want the branch of \coq{SomeOrNoneA } to approximate both
\coq{None } and \coq{Some }, this looks promising.

Unfortunately, we run into problems when deciding to use \coq{join_op } in the
definition for a bind method. Say that we were the replace the earlier
definition of \coq{bind_optionAT } with the following.

\begin{listing}[H]
\begin{minted}{coq}
  Definition bind_optionAT {A B} `{Joinable B}
    (Mma : optionAT M A)
    (f : A -> optionAT M B) : optionAT M B :=
  bindM (M:=M) Mma (λ ma,
    match ma with
    | NoneA => returnM NoneA
    | SomeA a => f a
    | SomeOrNoneA a => (returnM NoneA) ⊔ (f a)
    end).
\end{minted}
\caption{bind\_optionAT with a join\_op}
\label{lst:bind_optionAT_join}
\end{listing}

In the case of \coq{SomeOrNoneA }, we now join the results of both branches. As long
as the cases for \coq{NoneA } and \coq{SomeA } are sound with respects to the 
cases \coq{None } and \coq{Some } in the bind method for \coq{option }, 
the result for \coq{SomeOrNoneA } is sound
as well. This is by virtue of the laws for join we discussed above.

However, in order for us to have access to a join operator, we need to have the
encapsulated monad be an instance of Joinable. Because \coq{optionAT M A } is 
an alias for \coq{M (optionA A) }, that means that we need the
encapsulated monad M to be Joinable. 

This poses a problem. For example, say that we would encapsulate the option
monad. The Joinable instance for option is predicated on the fact that the inner
value \coq{A } is also joinable. This is necessary to be able to join two values of
\coq{Some } constructors. This constraint would then pass on to our optionAT
monad, but monads should not place restrictions on the values they wrap.

The same goes for if we were to wrap optionAT around a State monad. The join
operator for State is 
\coq{λ m1, λ m2, λ st, (m1 st) ⊔ (m2 st) }.
Because states have the type signature \coq{S -> (A * S) }, we are calling the
join operator for pairs, which also requires both components of the pair to be
joinable. Again, we end up with a constraint for the wrapped value A.

However, joining the wrapped value is also not what we were looking for. In
order for the bind method to be sound, it needs to join on the side effects,
not on the wrapped value. The actual function we are looking for, in the case
of State, looks more like 
\coq{λ m, λ st, let (a, st') := m st in (a, st ⊔ st'). }

The above insight led us to develop an instance for bindM specific to adding
the option functionality to the State monad.

\begin{minted}{coq}
  Context {S : Type} {JS : Joinable S S} {JI : JoinableIdem JS}.
  Context {M : Type → Type} {MM : Monad M}.

  Definition bind_optionAT_stateT {A B} 
    (m : optionAT (StateT S M) A)
    (f : A -> optionAT (StateT S M) B) : optionAT (StateT S M) B :=
  λ s : S, m s >>= λ '(o, s'),
    match o with
    | NoneA => returnM (NoneA, s')
    | SomeA x => (f x s')
    | SomeOrNoneA x => (f x s') >>= λ '(o', s''),
        match o' with 
        | NoneA => returnM (NoneA, s' ⊔ s'')
        | SomeA x' => returnM (SomeOrNoneA x', s' ⊔ s'')
        | SomeOrNoneA x' => returnM (SomeOrNoneA x', s' ⊔ s'')
        end
    end.
\end{minted}

This definition satisfies our requirement on the joining of the side effect
of the underlying monad \coq{(StateT M) }, without requiring a join on the
types \coq{A } or \coq{B }. Indeed, because we now join on the carried state we
are able to prove this bind operation sound.

However, we run into an new problem. The above bind method is not associative,
which means that a monad transformed by our \coq{optionAT } monad transformer
is no longer a monad as it does not obey the monadic laws. This observation
does not appear to be new, as Maillard et al. remark that there is no proper
monad transformer know for the nondetermenistic
monad~\cite{maillard2019dijkstra}, of which our option
monad is a simpler form.

Associativity of the bind function is not necessary for our soundness proofs.
We can proof that soundness is retained not only via equality, but also when a
new result is demonstrably an overapproximation of the previous result.
Starting with this insight, we try and define a weaker set of monad laws. We
call types that satisfy these laws lax monads. These laws are almost equal to
the standard monadic laws, except for replacing equality by a less-than
operator.

To be able to define a less-than operator for monads, we also introduce a new
type of monad called ordered monads, the definition of which is given below.
For our definition of ordered monads, we are inspired by the ordered monads
from~\cite{maillard2019dijkstra}. However, we place additional monotonicity 
constraints on the continuations \coq{f, f' }, as the monotonicity of the entire
bind method did not follow from the constraints given by Maillard et al.

\begin{minted}{coq}
Class OrderedMonad M {RO : return_op M} {BO : bind_op M} : Type :=
{
  monad_preorder : ∀ {A}, PreorderedSet A → PreorderedSet (M A);
  return_monotone : ∀ {A} {PA : PreorderedSet A} (a1 a2 : A),
    a1 ⊑ a2 → returnM a1 ⊑ returnM a2;
  bind_monotone : ∀ {A B} {PA : PreorderedSet A} {PB : PreorderedSet B} 
   (m m' : M A) (f f' : A → M B),
   m ⊑ m' → 
   (∀ a a' : A, a ⊑ a' → (f a) ⊑ (f a')) → 
   (∀ a : A, (f a) ⊑ (f' a)) →
   (m >>= f) ⊑ (m' >>= f');
}.
\end{minted}

The typeclasses \coq{return_op } and \coq{bind_op } are classes that are
instantiated by all types that are equipped with return and bind functions. All
of our defined monads are members of this class. We have split the \coq{returnM
} and \coq{bindM } functions into seperate classes to able to define them
without having to proof the monad laws that come with the \coq{Monad }
typeclass.

\begin{minted}{coq}
Class LaxMonad M `{OM : OrderedMonad M} : Type :=
{
  bind_id_left_lax : ∀ {A B} {PA : PreorderedSet A} {PB : PreorderedSet B}
    (f : A → M B) (a : A),
     (returnM a >>= f) ⊑ (f a);
  bind_id_right_lax : ∀ {A} {PA : PreorderedSet A} (m : M A),
    (m >>= returnM) ⊑ m;
  bind_assoc_lax : ∀ {A B C} {PB : PreorderedSet B} {PC : PreorderedSet C}
    (m : M A) (f : A → M B) (g : B → M C),
    ((m >>= f) >>= g) ⊑ (m >>= (λ a, (f a) >>= g));
}.
\end{minted}
