\section{Methodology}
We have decided on an incremental approach to developing the framework. We will
start out by defining the requisite mathematical constructs, such as the
orderings and Galois connections, in Coq. Building on these definitions, we
should then be able to define what it means for an abstract interpreter to be
sound, and provide a rudimentary implementation of a concrete and abstract
interpreter for a toy language.

After defining these basics steps, we will then improve upon it by incorporating
the design of~\cite{keidel2018compositional}, extracting a shared interpreter
from the concrete and abstract interpreters. By proving lemmas about the
shared interpreter and the concrete and abstract implementations, it is hoped
that the resulting proof would be easier to develop than a comparative proof
written for an abstract and concrete interpreter that are not so similarly
structured.

The end result is intended to be a framework to ease the development of formal
proofs of the soundness of abstract interpreters in Coq. It should be possible
for the developers of those proof to define their concrete and abstract
interpreters and receive a series of lemmas to prove. The soundness of the
interpreters should follow from those for free 
by~\cite{keidel2018compositional}.

After the framework has been written, we will verify if the usage of the
framework will indeed result in easier proofs by performing a case study on an
abstract interpreter.

\subsection{Coq}
The work of Coquand et al~\cite{coquand1986calculus} eventually led to the
development of Coq, an interactive proof assistant. Coq implements the calculus
of constructions, a system for constructive proofs. By using proof assistants 
we can mechanically prove the soundness of analyzers. 
However, this is still not often done. It is difficult to
pinpoint the exact reason for this, but we will proceed under the assumption
that the required effort remains to large for the perceived gains. 

We have used Coq to write our definitions and
prove the soundness of the abstract interpreter. ~\cite{coqintroduction}.
In this section, we will give some examples of Coq code along with an
explanation of what is meant by the code. Readers familiar with Coq can skip
this section. Other readers may wish to read it to help understand later code
listings.

\begin{minted}{coq}
Inductive option (A : Type) : Type := 
  | Some : A → option A
  | None : option A.
\end{minted}
In Coq, we can define types using the Inductive command. In the above example,
from the standard library,
we define a type \coq{option } with two constructors, \coq{Some }
and \coq{None }. A constructor is a function that can create the
inductive type. The \coq{Some } constructor takes one
argument and \coq{None } doesn't take any. The option type is dependent on the
provided type \coq{A }, meaning that for every type \coq{A }, 
there exists a type \coq{option A }.

\begin{minted}{coq}
Definition optionT (M : Type → Type) (A : Type) : Type := M (Maybe A).

Definition parity_plus (p q : parity) : parity :=
  match p, q with 
  | par_even, par_even | par_odd, par_odd  => par_even
  | par_odd, par_even  | par_even, par_odd => par_odd
  end.
\end{minted}

The \coq{Definition } command creates type aliases or functions. 
In the first case, we
bind the identifier \coq{MaybeT M A } to \coq{M (Maybe A) }. The definition
also requires that the parameters \coq{M } and \coq{A } be of types \coq{Type
-> Type } and \coq{Type } respectively.

The second \coq{Definition } defines a function \coq{parity_plus } that takes
two parities \coq{p } and \coq{q } and returns a new parity. Via the match
tactic, Coq looks at which constructors where used to build \coq{p } and
\coq{q } and returns the value associated with that case. The pipe symbol \coq{| }
precedes a set of constructors for \coq{p } and \coq{q } and can be used to
group cases together that have the same output. An underscore indicates that
we are not interested in the specific value. 

\begin{minted}{coq}
Definition parity_plus_lambda : parity → parity → parity :=
    λ p, λ q, 
        match p, q with 
        | par_even, par_even | par_odd, par_odd  => par_even
        | par_odd, par_even  | par_even, par_odd => par_odd
        end.

Definition swap {A B} : (A*B) -> (B*A) :=
    λ '(a,b), (b, a).
\end{minted}

We can also define lambda functions using the above syntax. In the definition
for \coq{swap }, \coq{'(a,b) } means that the provided value should be a pair.

\begin{minted}{coq}
Lemma parity_plus_par_even : forall p,
  parity_plus p par_even = p.
Proof. intros. destruct p; reflexivity. Qed.
\end{minted}

The value of Coq comes from the ability to take those definitions and proof
properties about them. We start a proof with the \coq{Lemma } command. In the
above example, we define a lemma called \coq{parity_plus_par_even} which
states that for all parities, adding a value of \coq{par_even } does not change
the original value. Proofs are delimited by the \coq{Proof.} and \coq{Qed.} 
commands. In between these commands come a series of \emph{tactics}. 

There are several other commands we can use to define a lemma. These keywords 
\coq{Theorem }, \coq{Lemma }, \coq{Corollary }, \coq{Remark }, \coq{Fact } and 
\coq{Proposition } are all equivalent. Any
semantic difference is up to the developer. In our work, we will mostly use the
\coq{Lemma } keyword. We shall use the \coq{Theorem } keyword for the final proof 
stating the soundness of the interpreters. On occassion, we will use the 
\coq{Corollary } command to state a lemma that follows trivially from the 
preceding lemma.

\begin{minted}{coq}
Notation "℘ A" := (A → Prop) (at level 0, only parsing).
Definition union {U : Type} (A B : ℘ U) : ℘ U :=
  λ u : U, A u ∨ B u.
Infix "∪" := union (at level 40).
\end{minted}

To keep our Coq code close to the mathematical theory behind it, we introduce a
lot of notations. The \coq{Notation } command allows us to introduce those
notations to Coq. The new notation is between the quotes, which its definition
following after the \coq{:= }. The term between the second pair of brackets
is technical information about how Coq should parse the notation, such as
left or right associativity. The \coq{Infix } command is a shorthand for
introducing a infix notation for a binary function.

\begin{minted}{coq}
Class Galois (A A' : Type) : Type :=  γ : A -> ℘ A'.
\end{minted}

In this thesis we utilize the typeclass mechanism of Coq. Typeclasses are a way
to define methods and lemmas for types that implement that typeclass. In the
above example, we define a Galois typeclass that takes two types. It states that
implementations of this typeclass should define a function \coq{γ} of type
\coq{A' -> ℘ A}.

\begin{minted}{coq}
Inductive gamma_par : parity → ℘ nat :=
  | gamma_par_even : ∀ n, Nat.Even n → gamma_par par_even n
  | gamma_par_odd  : ∀ n, Nat.Odd n → gamma_par par_odd n.
Hint Constructors gamma_par : soundness.

Instance galois_parity_nat : Galois parity nat := gamma_par.
\end{minted}

To create an instance of a typeclass, we need to define the required functions
and lemmas. Here, we have defined an inductive relation called \coq{gamma_par}
that relates instances of \coq{parity } with sets of natural numbers. 
We then use that definition in creating an \coq{Instance} of the Galois typeclass.

\begin{minted}{coq}
Context {M : Type -> Type} {MM : Monad M}.
\end{minted}

The \coq{Context } command allows us to add requirements to a section. Anything
defined following the command while have those requirements added implicitly.
